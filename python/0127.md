## OOP

### 1. 객체(Object)

- 파이썬에서 모든 것은 객체다.
- 모든 객체는 타입(type), 속성(attribute), 조작법(method)을 가진다.
- 타입 : 어떤 연산자와 조작이 가능한가?
- 속성 : 어떤 상태(데이터)를 가지는가?
- 조작법 : 어떤 행위(함수)를 할 수 있는가?
- 객체는 자신 고유의 속성(Attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다.



#### 1.1 타입(Type)과 인스턴스(Instance)

- 타입 : 공통된 속성과 조작법을 가진 객체들의 분류
- 인스턴스 : 특정 타입의 실제 데이터 예시. 파이썬에서 모든 것은 객체고 모든 객체는 특정 타입의 인스턴스다. 특정 클래스로부터 생성된 해당 클래스이 실체



#### 1.2 속성(Attribue)과 메서드(Method)

- 속성 : 객체의 상태/데이터를 뜻한다. `객체.속성` 
- 메서드 : 특정 객체에 적용할 수 있는 행위를 뜻한다. `객체.조작법()`
- 특정 타입의 객체가 가지는 속성과 메서드를 보는 방법 : `dir(객체)`



### 2. 객체 지향 프로그래밍(Object-Oriented Programming)

- 컴퓨터 프로그램을 명령어의 목록으로 보지 않고 여러 개의 독리된 단위, 즉 `객체`들의 모임으로 파악한다.

- 장점 : 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어 개발에 많이 사용한다. 배우기 쉽고 개발과 보수가 간편하며 직관적 코드 분석을 가능하게 한다.



### 3. 클래스(Class)와 객체(Object)

- 타입 : 공통 속성을 가진 객체들의 분류(class)
- 클래스 : 객체들의 분류(class)를 정의할 때 쓰이는 키워드
- 공통된 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형



#### 3.1 클래스의 생성

- 클래스 내부에는 데이터와 함수를 정의할 수 있고, 이 때 데이터는 속성, 정의된 함수는 메서드라고 불린다.

```python
class <클래스이름>:
    <statement>
```



#### 3.2 인스턴스의 생성

- 정의된 클래스에 속하는 객체를 해당 클래스의 인스턴스라고 한다.
- 인스턴스 = 클래스()



#### 3.3 메서드의 정의

- 특정 데이터 타입(또는 클래스)의 객체에 공통적으로 적용 가능한 행위들을 의미한다.

##### 3.3.1 self

- 파이썬에서 인스턴스 메서드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계되었다.
- 보통 매개변수명으로 self를 첫번째 인자로 설정(다른 이름도 가능하지만 일반적인 규칙)

##### 3.3.2 생성자(Constructor) 메서드

- 인스턴스 객체가 생성될 때 호출되는 함수
- 생성자를 활용하면 인스턴스가 생성될 때 인스턴스의 속성을 정의할 수 있다.

```python
def __init__(self):
    
```

##### 3.3.3 소멸자(destructor) 메서드

- 인스턴스 객체가 소멸(파괴)되기 직전에 호출되는 함수

```python
def __del__(self):
    
```



#### 3.4 속성(Attribute) 정의

- 특정 데이터 타입(또는 클래스)의 객체들이 가지게 될 상태/데이터를 의미한다.
- 생성자 함수를 통해 생성과 동시에 인스턴스 속성에 값을 할당하거나  변경할 수 있습니다.

```python
class Person:
    def __init__(self, name):
        self.name = name
jason = Person('jason')
jason.name = 'josh'
```



#### 3.5 매직메서드

- 더블언더스코어가 있는 메서드는 특별한 일을 하기 위해 만들어진 메서드기 때문에 스페셜 메섣, 매직 메서드라고 불립니다.

##### 3.5.1 `__str(self)__`

- 특정 객체를 출력할 때 보여줄 내용을 정의할 수 있음

```python
>>> class Person:
	def __init__(self, name):
		self.name = name
	def __str__(self):
		return f'출력 시 보여줄 내용입니다.'

	
>>> jason = Person('jason')
>>> print(jason)
출력 시 보여줄 내용입니다.
```



### 4. 인스턴스 & 클래스 변수

#### 4.1 인스턴스 변수

- 인스턴스의 속성(attribute)
- 각 인스턴스들의 고유한 변수
- 메서드 정의에서 `self.변수명`으로 정의
- 인스턴스가 생성된 이후 `인스턴스.변수명`으로 접근 및 할당

```python
>>> class Person:
	def __init__(self, name):
		self.name = name      # 인스턴스 변수
        
>>> jason = Person('jason')
```





#### 4.2 클래스 변수

- 클래스의 속성(attribute)
- 모든 인스턴스가 공유
- 클래스 선언 내부에서 정의
- `클래스.변수명`으로 접근 및 할당

```python
>>> class Person:
	species = 'human'  #클래스 변수
```



### 5 인스턴스 & 클래스간의 이름공간

#### 5.1 이름공간 탐색 순서

- 클래스를 정의하면, 클래스가 생성됨과 동시에 이름 공간이 생성된다.
- 인스턴스를 만들면 인스턴스 객체가 생성되고 해당되는 이름 공간이 생성된다.
- 인스턴스의 속성(attribute)가 변경되면, 변경된 데이터를 인스턴스 객체 이름 공간에 저장한다.
- 인스턴스에서 특정 속성에 접근하면 인스턴스->클래스 순으로 탐색한다.



### 6 메서드의 종류

#### 6.1 인스턴스 메서드

- 인스턴스가 사용할 메서드
- 클래스 내부에 정의되는 메서드의 기본값은 인스턴스 메서드
- 호출시, 첫번째 인자로 인스턴스 자기자신 `self`이 전달됨

```python
class MyClass:
    def instance_method(self, arg1, arg2, ...):
        ...
```



#### 6.2 클래스 메서드

- 클래스가 사용할 메서드
- `@classmethod` 데코레이터를 사용하여 정의
- 호출시, 첫 번째 인자로 클래스 `cls`가 전달됨

```python
class MyClass:
    @classmethod
    def class_method(cls, arg1, arg2, ...):
        ...
```



#### 6.3 스태틱 메서드

- 클래스가 사용할 메서드
- `@staticmethod` 데코레이터를 사용하여 정의
- 호출시, 어떠한 인자도 전달되지 않음

```python
class MyClass:
    @staticmethod
    def static_method(arg1, arg2, ...):
        ...
```



#### 6.4 비교 정리

##### 6.4.1 인스턴스와 메서드

- 인스턴스는 3가지 메서드 모두에 접근할 수 있다.
- 하지만 인스턴스에서는 클래스 메서드와 스태틱 메서드는 호출하지 않아야 한다.
- 인스턴스가 할 행동은 모두 인스턴스 메서드로 한정 지어서 설계한다.



##### 6.4.2 클래스와 메서드

- 클래스도 3가지 메서드 모두에 접근할 수 있다.
- 하지만 클래스에서 인스턴스 메서드는 호출하지 않는다.
- 클래스가 할 행동은 다음 원칙에 따라 설계한다.(클래스 메서드, 정적 메서드)
  - 클래스 자체와 그 속성에 접근할 필요가 있다면 `클래스 메서드`로 정의한다.
  - 클래스와 클래스 속성에 접근할 필요가 없다면  `정적 메서드`로 정의한다.



### 7 상속

#### 7.1 상속이란?

- 클래스의 가장 큰 특징은 `상속`이 가능하다는 것이다.
- 부모 클래스의 모든 속성이 자식 클래스에게 상속 되므로 코드 재사용성이 높아진다.

- issubclass(Child, Parent)를 통해 상속관계를 확인해 볼 수 있다.
- isinstance(instance, Class)를 통해 인스턴스인지 확인할 수 있다.
- isinstance를 통해 자식클래스에서 생성한 인스턴스와 부모 클래스를 확인하면 True라고 나온다.
- 하지만 Type은 서로 다르다.



> - `class.``mro`()
>
>   이 메서드는 인스턴스의 메서드 결정 순서를 사용자 정의하기 위해 메타 클래스가 재정의할 수 있습니다. 클래스 인스턴스를 만들 때 호출되며 그 결과는 [`__mro__`](https://docs.python.org/ko/3.8/library/stdtypes.html?highlight=mro#class.__mro__) 에 저장됩니다.
>
> - `class.``__subclasses__`()
>
>   각 클래스는 직계 서브 클래스에 대한 약한 참조의 리스트를 유지합니다. 이 메서드는 아직 살아있는 모든 참조의 리스트를 돌려줍니다. 예:

```python
>>> bool.mro()
[<class 'bool'>, <class 'int'>, <class 'object'>]

>>> int.__subclasses__()
[<class 'bool'>, <enum 'IntEnum'>, <enum 'IntFlag'>, <class 'sre_constants._NamedIntConstant'>]
```



#### 7.2 super()

- 자식 클래스에 메서드를 추가로 구현할 수 있다.
- 부모 클래스의 내용을 사용하고자 할 때, super()를 사용할 수 있다.

```python
>>> class Home:
	human = 0
	def __init__(self, name):
		self.name = name
		Home.human += 1

		
>>> class Children(Home):
	def __init__(self, name, age):
		super().__init__(name)      # 부모클래스의 init()을 실행하고
		self.age = age              # 추가로 생성할 내용만 입력해준다.
```



### 8 메서드 오버라이딩

- 자식 클래스에서 부모 클래스의 메서드를 재정의하는 것
- 상속 받은 메서드를 재정의 할 수도 있다.
- 상속 받은 클래스에서 같은 이름의 메서드로 덮어쓴다.

```python
>>> class Home:
	human = 0
	adult = 0
	def __init__(self, name, age):
		self.name = name
		self.age = age
		Home.human += 1
	def count_family(self):
		print("한 명 추가")

		
>>> class Adult(Home):
	def __init__(self, name, age):
		super().__init__(name, age)
	def count_family(self):
		Home.adult += 1
		Home.human += 1
		print("어른 한 명 추가")
        
>>> a = Home('김일', 6)
>>> a.count_family()
한 명 추가
>>> b = Adult('김이', 22)
>>> b.count_family()
어른 한 명 추가
```



#### 8.1 상속관계에서의 이름공간

- 기존 `인스턴스->클래스` 순으로 이름 공간을 탐색하는 과정에서 상속관계에 있으면 확장된다.
- `인스턴스->자식클래스->부모클래스->전역`



### 9 다중 상속

- 두 개 이상의 클래스를 상속받는 경우, 다중 상속이 된다.
- 상속 순서에 따라 어떤 메서드를 실행할지 결정됩니다.
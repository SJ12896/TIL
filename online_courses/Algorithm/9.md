## 동적계획법(Dynamic Programming)

- 문제를 더 작은 문제로 분할하되, 상향식으로 문제를 해결한다. 
- 메모이제이션 : 가장 작은 입력 사례 해답을 테이블에 저장하고 필요할 때 꺼내 쓴다.



#### 문제풀기

1. 문제 해결할 수 있는 재귀 관계식을 구한다.
2. 가장 작은 입력사례로부터 상향식 방법으로 문제를 해결한다.



#### 분할정복 VS 동적계획법

- 분할 해결은 동일
- 분할 정복 : 재귀 호출 통해 분할 정복 Top-down
- 동적계획 : 메모이제이션을 통해 상향식 정복 Bottom-up



### 최단 경로(플로이드 알고리즘)

- 모든 장점의 쌍에 대한 최단 경로 구하기 -> 같은 정점을 두번 가치지 않는다.
- 최단 경로 문제는 최적화 문제. (하나 이상 답 후보가 있고 그 중 최적의 값을 찾아야한다.)
- 입력 : 인접 행렬 -> 가는 길이 없으면 무한대 값을 준다.
- 최단 경로 행렬 : 중간에 몇 개의 정점을 거치는지를 전부 구한다(안거치고 바로 가는 루트부터 전부 거쳐서 가는 루트까지.) 

1. 재귀 관계식을 찾는다. 인접 행렬에서 최단 경로 행렬과의 재귀 관계식 구하기 -> k개를 거쳐 가는 방식은 k-1개를 거쳐 가는 방식으로부터 구한다. 하나 더 거쳐도 새로운 최단 경로가 없으면 그대로, 있으면 새로운 값으로 바꾼다.

   - i에서 k를 거쳐 j로 가는 방식이 최단 경로면 i->k도 최단 경로고 k->j도 최단 경로다. 

   ```python
   def floyd(W):
       D = W
       n = len(W)
       P = [[-1] * n for _ in range(n)]
       for k in range(n):
           for i in range(n):
               for j in range(n):
                   D[i][j] = min(D[i][j], D[i][k] + D[k][j])
                   # if D[i][j] > D[i][k] + D[k][j]:
                   	# D[i][j] = D[i][k] + D[k][j]
                       # p[i][j] = k
       return D
   ```

   - 경로를 구하기 위해서는 과정을 기록할 필요가 있다. 그래서 p를 추가한다. P[i][ j  = -1이면 ij가 최단경로. k면 i~k 최단 경로 출력 후 k 출력 후 k j의 최단경로 출력

1. 상향식 방법으로 해답을 구한다.
### 1. 주기억장치 관리  Main Memory Management

- 메모리 역사 : core, 진공관, 트랜지스터(반도체 칩안의 소자), 집적회로(SRAM, DRAM)
- 메모리 용량 : 예전엔 메모리관리가 너무 어려웠다. 작고 비쌌기 때문에. 1970년대 8bit, pc64kb -> 1980 16bit. -> 1990 수mb에서 수십mb > 2000 수백mb에서 수gb. 늘어나면서 지금은 충분히 커졌을거라고 생각하지만 여전히 부족하다. 
- 언제나 부족한 메모리 : 프로그램이 기계어, 어셈블리어에서 c언어 -> 자바같은 객체지향언어 로 진화하는데다가 숫자 처리에서 문자처리, 멀티미디어 처리에서 빅데이터로 프로그램이 계속 커지기 때문이다.
- 메모리를 효과적으로 사용하기 위해서는? 메모리 낭비를 없애고 가상 메모리를 사용한다. 
- 프로그램을 메모리에 올리기
  - 메모리 구조 : 주소 + 데이터, memory에 입력으로 address, 출력으로 data. cpu와 서로 양방향으로 주고받는다.
  - 프로그램 개발 : 원천파일Source file : 고수준, 어셈블리어, complier를 통해 다음 걸로(하이레벨 언어를 기계어로 번역) -> 목적파일Object file: 컴파일 또는 어셈블 결과, link 을 통해 다음걸로(print처럼 미리 만들어진 함수같은게 모여있는게 라이브러리. print는 우리가 짠 게 아니니까 원천 파일에 없다. 그래서 목적 파일에도 없기 때문에 다음 단계를 가면서 linker를 통해 가져온다.) -> 실행파일Executable file : 링크 결과,  실행파일이 메모리에 올라가는 걸 로드 라고 한다.(적재해주는 거의 이름은 로더)
  - 프로그램 실행 : code(기계어에 해당하는 부분) + data + stack(함수호출에서 돌아오는 주소, 지역변수 등을 저장)
  - 실행파일을 메모리에 올리기 : 메모리 몇번지에? -> os 메모리 관리부서의 loader가 해준다. 다중 프로그래밍으로 저번에 다른 번지에 들어가게된다. 어디에 배치되어도 MMU(cpu와 메모리 사이에 존재)안의 재배치 레지스터가 cpu가 볼 때는 원래 번지에, 실제로는 다른 번지에 들어가 있다.


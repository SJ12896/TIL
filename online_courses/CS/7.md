### 1. 주기억장치 관리  Main Memory Management

- 메모리 역사 : core, 진공관, 트랜지스터(반도체 칩안의 소자), 집적회로(SRAM, DRAM)
- 메모리 용량 : 예전엔 메모리관리가 너무 어려웠다. 작고 비쌌기 때문에. 1970년대 8bit, pc64kb -> 1980 16bit. -> 1990 수mb에서 수십mb > 2000 수백mb에서 수gb. 늘어나면서 지금은 충분히 커졌을거라고 생각하지만 여전히 부족하다. 
- 언제나 부족한 메모리 : 프로그램이 기계어, 어셈블리어에서 c언어 -> 자바같은 객체지향언어 로 진화하는데다가 숫자 처리에서 문자처리, 멀티미디어 처리에서 빅데이터로 프로그램이 계속 커지기 때문이다.
- 메모리를 효과적으로 사용하기 위해서는? 메모리 낭비를 없애고 가상 메모리를 사용한다. 
- 프로그램을 메모리에 올리기
  - 메모리 구조 : 주소 + 데이터, memory에 입력으로 address, 출력으로 data. cpu와 서로 양방향으로 주고받는다.
  - 프로그램 개발 : 원천파일Source file : 고수준, 어셈블리어, complier를 통해 다음 걸로(하이레벨 언어를 기계어로 번역) -> 목적파일Object file: 컴파일 또는 어셈블 결과, link 을 통해 다음걸로(print처럼 미리 만들어진 함수같은게 모여있는게 라이브러리. print는 우리가 짠 게 아니니까 원천 파일에 없다. 그래서 목적 파일에도 없기 때문에 다음 단계를 가면서 linker를 통해 가져온다.) -> 실행파일Executable file : 링크 결과,  실행파일이 메모리에 올라가는 걸 로드 라고 한다.(적재해주는 거의 이름은 로더)
  - 프로그램 실행 : code(기계어에 해당하는 부분) + data + stack(함수호출에서 돌아오는 주소, 지역변수 등을 저장)
  - 프로그램을 메모리에 올리기 : 메모리 몇번지에? -> os 메모리 관리부서의 loader가 해준다. 다중 프로그래밍으로 저번에 다른 번지에 들어가게 되는데 만들어질 때 특정 메모리 위치에서 동작하도록 설계된 프로그램은 어떻게 해야할까? 어디에 배치되어도 MMU(cpu와 메모리 사이에 존재)안의 재배치 레지스터가 cpu가 볼 때는 원래 번지(물리 주소)에, 실제로는 다른 번지(논리 주소)에 들어가 있다.



### 2. 메모리 절약

- 메모리 낭비 방지
- 동적 적재(Dynamic Loading) : 만들어진 실행 파일을 메모리에 올리는 것을 load라고 한다. 프로그램 실행에 반드시 필요한 루틴/데이터만 적재하는 것이 동적 적재다. 모든 루틴이 다 사용되지는 않는다.(예를 들어 오류 처리. 오류가 났을 때만 올라가게 한다.) 모든 데이터가 다 사용되는 건 아니다. 그래서 실행 시 필요하면 그 때 해당 부분을 메모리에 올린다. 현대 운영체제는 거의 동적 적대다. 반대는 정적 적재(Static Loading)
- 동적 연결(Dynamic Linking) : 여러 프로그램에 공통 사용되는 라이브러리. 공통 라이브러리 루틴을 메모리에 중복으로 올리는 건 낭비다. 라이브러리 루틴 연결을 실행 시까지 미룬다.(예를 들어 두 프로그램에서 모두 printf를 사용한다면? 똑같은 코드가 메모리에 올라가므로 낭비다.) 오직 하나의 라이브러리 루틴만 메모리에 적재되고, 다른 애플리케이션 실행은 이 루틴과 연결(link)된다. 반대는 정적 연결(Static Linking)
  - 공유 라이브러리(shared library)-Linux, 동적 연결 라이브러리(Dynamic Linking Library)-Windows(.dll파일들이 바로 동적 연결 라이브러리 파일)
- Swapping : 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지(메모리 활용도 높이기 위해 Backing store(=swap device)로 보낸다. (예를 들어 실행 파일 켜놓고 화장실만 다녀와도 메모리에 있는데 사용 안되고 있는 파일이 된다.) backing store크기는 대략 자신의 메인 메모리 크기 정도로. 
  - swap out, swap in
  - 프로세스 크기가 크면 backing store 입출력에 대한 부담이 커진다.
  - 재배치 레지스타 사용하기 때문에 적재 위치가 swap out전과 달라져도 상관없다.



### 3. 연속 메모리 할당 Contiguous Memory Allocation

- 다중 프로그래밍 환경(메모리에 여러 개의 프로세스가 동작)
  - 부팅 직후 메모리 상태 : O/S -> big single hole (처음에 메모리가 비어있기 때문에)
  - 프로세스 생성 & 종료 반복 : scattered holes (프로세스가 군데 군데 시작되었다 종료되면서 듬성듬성 빈 공간이 생긴다.) / 조각들을 fragment라고 한다. 메모리 단편화, 내부 단편화 -> hole들이 불연속하게 떨어져있으면 빈공간이 나뉘어져서 작아진다. 그래서 새로운 프로세스가 메인메모리로 올라갈 때 빈 공간에 들어갈 수 없다.
- 연속 메모리 할당
  - 방식 : first-fit, best-fit, worst-fit : 최초, 최적, 최악
    - first-fit : 들어갈 수 있는 첫 번째 hole에 프로세스를 넣는다.
    - best-fit : 들어갈 수 있는 hole중 가장 사이즈가 비슷한 곳에 넣는다.
    - worst-fit : 들어갈 수 있는 hole중 가장 차이가 많이 나는 곳에 넣는다. ( 이 경우 다시 생기는 hole크기가 크기 차이가 얼마 안나는곳에 넣었을 때 보다 커지기 때문에 다른 걸 또 넣을 수도 있다. 그래도 사실상 효율이 가장 떨어진다.)
  - 성능 비교 (속도 및 메모리 이용률) : 속도(first-fit), 이용률(first-fit, best-fit)
  - 외부 단편화로 인한 메모리 낭비 : 1/3수준 (사용 불가), Compaction (최적 알고리즘 없음, 고부담) -> hole들을 한 곳으로 모으는 방법. 메모리를 움직여야하니까 고부담. 또 hole을 가장 적게 움직이는 방법을 결정하는 게 복잡하기 때문에 최적 알고리즘이 없다.
  - compaction이외의 방법은? 
- 페이징(Paging) : 프로세스를 항상 연속해서 넣어야 한다고 생각해 위와 같은 문제가 생겼다. 대신 새로 넣는 프로세스를 일정 간격으로 자른다. hole 역시 같은 단위로 자른다. 그래도 프로그램 실행이 가능할까? 실행할 수 있도록 CPU를 속인다.(마치 MMU로 주소를 속일 때 처럼 재배치 레지스터 값을 조정해서. 여기서는 MMU가 아니라 Page Table이라고 한다.)
  - 페이지 : 프로세스 일정 크기로 자른 것 (프로세스는 페이지의 집합)
  - 프레임 : 메모리 일정 크기로 자른 것 (페이지의 크기와 같다, 메모리는 프레임의 집합)
- 주소 변환(Address Translation)
  - 논리주소(Logical address)
    - CPU가 내는 주소는 2진수로 표현 (전체 m비트)
    - 하위 n비트는 오프셋offset 또는 변위displacement라고 하며 상위 m-n비트는 페이지의 번호가 된다.
  - 주소 변환 : 논리주소 -> 물리주소(Physical address)
    - 페이지 번호(p)는 페이지 테이블 인덱스 값
    - 번호에 해당하는 테이블 내용이 프레임 번호(f)
    - 변위(d)는 변하지 않는다.
    -  ex) 50번지는 110010. 한 페이지를 16바이트로 정했으면 밑의 4개는 변위로 0010, 10진수 2. 페이지 번호는 11이라 10진수 3. 페이지 테이블 3의 내용이 8이면 그거에 따라 바뀐다. 그래서 1000(f)0010(p), 그리고 이게 다시 10진수로 바뀐 130이 최종 물리 주소 값.
- 내부단편화, 페이지테이블
  - 내부 단편화(Internal Fragmentation) : 프로세스 크기가 페이지 크기의 배수가 아닐 때 (ex: 프로세스가 15바이트고 페이지 크기가 4바이트면 4개의 페이지가 필요한데 마지막 1바이트가 남는다.) 
    - 페이징으로 외부 단편화는 줄였으나 내부 단편화가 생김. 하지만 외부 단편화에 비해 메모리 낭비가 미미한 수준이다. 최대로 남는 메모리는 페이지크기 -1바이트
  - 페이지 테이블 만들기
    - CPU 레지스터 : 장점은 CPU안에 있어 주소 변환이 빠르다. 단점은 CPU안에 넣어야하기 때문에 많이 못들어간다.
    - 메모리 : 장점은 많이 들어갈 수 있다. 단점은 변환속도가 느리다.(한 번 변환하려면 주소 읽을 때마다 여기저기 가야해서)
    - 위 두개는 실제로 잘 안씀
    - TLB(Translation Lock-asdie Buffer) : 캐시 메모리인데(s-ram, 빠름) 주소 변환 페이지 테이블 목적으로 만든 것은 TLB라고 한다. 
      - 유효 메모리 접근시간(Effective Memory Access Time) : 메모리에서 어떤 내용 읽어오는데 걸리는 유효한 시간


### 1. 페이징

- 페이징(Paging) : 프로세스를 항상 연속해서 넣어야 한다고 생각해 위와 같은 문제가 생겼다. 대신 새로 넣는 프로세스를 일정 간격으로 자른다. hole 역시 같은 단위로 자른다. 그래도 프로그램 실행이 가능할까? 실행할 수 있도록 CPU를 속인다.(마치 MMU로 주소를 속일 때 처럼 재배치 레지스터 값을 조정해서. 여기서는 MMU가 아니라 Page Table이라고 한다.)

  - 페이지 : 프로세스 일정 크기로 자른 것 (프로세스는 페이지의 집합)
  - 프레임 : 메모리 일정 크기로 자른 것 (페이지의 크기와 같다, 메모리는 프레임의 집합)

  

- 주소 변환(Address Translation)

  - 논리주소(Logical address)

    - CPU가 내는 주소는 2진수로 표현 (전체 m비트)
    - 하위 n비트는 오프셋offset 또는 변위displacement라고 하며 상위 m-n비트는 페이지의 번호가 된다.

  - 주소 변환 : 논리주소 -> 물리주소(Physical address)

    - 페이지 번호(p)는 페이지 테이블 인덱스 값
    - 번호에 해당하는 테이블 내용이 프레임 번호(f)
    - 변위(d)는 변하지 않는다.
    - ex) 50번지는 110010. 한 페이지를 16바이트로 정했으면 밑의 4개는 변위로 0010, 10진수 2. 페이지 번호는 11이라 10진수 3. 페이지 테이블 3의 내용이 8이면 그거에 따라 바뀐다. 그래서 1000(f)0010(p), 그리고 이게 다시 10진수로 바뀐 130이 최종 물리 주소 값.

    

- 내부단편화, 페이지테이블

  - 내부 단편화(Internal Fragmentation) : 프로세스 크기가 페이지 크기의 배수가 아닐 때 (ex: 프로세스가 15바이트고 페이지 크기가 4바이트면 4개의 페이지가 필요한데 마지막 1바이트가 남는다.) 

    - 페이징으로 외부 단편화는 줄였으나 내부 단편화가 생김. 하지만 외부 단편화에 비해 메모리 낭비가 미미한 수준이다. 최대로 남는 메모리는 페이지크기 -1바이트

  - 페이지 테이블 만들기

    - CPU 레지스터 : 장점은 CPU안에 있어 주소 변환이 빠르다. 단점은 CPU안에 넣어야하기 때문에 많이 못들어간다.

    - 메모리 : 장점은 많이 들어갈 수 있다. 단점은 변환속도가 느리다.(한 번 변환하려면 주소 읽을 때마다 여기저기 가야해서)

    - 위 두개는 실제로 잘 안씀

    - TLB(Translation Lock-asdie Buffer) : 캐시 메모리인데(s-ram, 빠름) 주소 변환 페이지 테이블 목적으로 만든 것은 TLB라고 한다. 

      - 유효 메모리 접근시간(Effective Memory Access Time) : 메모리에서 어떤 내용 읽어오는데 걸리는 유효한 시간

      

- 보호와 공유

  - 보호 : 해킹 등 방지. 모든 주소는 페이지 테이블을 경유하므로 페이지 테이블 엔트리마다 r(reader), w(writer), x(executor) 비트 두어 해당 페이지 접근 제어 가능. 각각 1또는0을 가질 수 있는데 1이 가능 0이 불가능 (ex: 111이면 셋 다 가능)

  - 공유 : 메모리 낭비 방지. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, code+data+stack에서 code는 공유 가능하기 때문에 메모리에서 변하지 않고 그 외만 변함. 

    - 단 non-self-modifying code(실행되면서 스스로 내용을 바꾸지 않는 코드) = reentrant code(다시 들어갈 수 있는 코드, 재진입가능 코드) = pure code(순수한 코드, 항상 그 내용 유지)인 경우. 프로세스의 테이블 코드 영역이 같은 곳을 가리키게

    - ex) 워드를 사용하는 3개의 프로세스.

- 페이징에서 자를 때 일정 크기로 자르기 때문에 어떤 페이지엔 code, 다른 페이지는 code+data, 다른 페이지는 data+stack처럼 부위 관계없이 섞여서 잘라진다. 이런식으로 잘리면 보호, 공유에서 설정이 애매하다. 그러나 세그멘테이션에선 다르다.



### 2 . 세그멘테이션 Segmentation

- 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치. 페이징은 그냥 일정 크기로 자른 것. 세그멘트는 연관 부위별로 의미있게 자르기. 페이징이 더 일반적으로 많이 사용된다고 함. 80년대 쯤에 세그멘테이션.

  - 프로세스는 세그멘트의 집합. 
  - 세그멘트 크기는 일반적으로 같지 않다.

- 세그멘트를 메모리에 할당

  - MMU 내의 재배치 레지스터 값을 바꿈으로써 CPU는 프로세스가 연속된 메모리 공간에 위치한다고 착각
  - MMU는 세그멘트 테이블이 된다.

- 논리주소(Logical address) : CPU가 내는 주소는 앞이 세그멘트 번호(세그멘트 테이블 인덱스 값), 뒤가 변위값

- 주소변환 : 논리주소 -> 물리주소

  - 세그먼트 테이블 내용 : base+limit

  - 세그멘트 번호 내용에 따라 시작 위치(base) 및 한계값 파악. base값에 변위값이 붙으면 물리주소
  - 물리주소 값 계산한게 한계를 넘어서면 segment violation 예외 상황 처리

- 보호와 공유

  - 페이징에서의 내용과 둘 다 동일한데 둘 다 페이징보다 우월하다는 차이점이 있다. 세그멘테이션은 부위별로 자르니까. 그런데 왜 페이징을 더 많이 사용할까?




### 1. 세마포

- 임계구역 문제 해결 : acquire()로 들어오고 release()로 나가게 코드를 짠다. 예를 들어 이미 parent의 입금이 일어나고 있으면 critical section안의 value가 0보다 작아 child가 acquire를 요청해도 바로 실행되지 않고 block에 들어가있다. 그 후에 parent의 release가 일어난 후 value값이 변경되고 child가 실행할 수 있다.
- 프로세스 실행 순서 정하기 : 초기값 0. p1, p2에 s1, s2가 있는데 cpu 스케줄링 알고리즘과 관게없이 s1이 무조건 먼저 실행되게 하려면? p2의 acquire를 호출하면 1이 감소되게 한다. 그래서 s2가 실행되지 못한다. 그래서 s1이 먼저 실행되고 release가 +1을 하면서 음수가 아니라 s2가 실행될 수 있게 된다.



### 2. 생산자-소비자 문제  Producer -Consumer Problem

- 전통적 동기화 예제 
- 창고에 생산물을 저장해두면 소비자가 소비한다. 컴퓨터로 말하면 창고가 버퍼. 창고가 가득차면 생산을 중단해야 한다.
- 생산자가 데이터를 생산하면 소비자는 소비
- 컴파일러 > 어셈블러(기계어로 번역해서 컴퓨터가 실행할 수 있게 해준다), 파일 서버 > 클라이언트, 웹 서버 > 웹 클라이언트
- 유한버퍼 문제(Bounded Buffer Problem) : 생산된 데이터는 버퍼에 일단 저장(생산과 소비의 속도 차이 같은 이유), 현실 시스템에서 버퍼 크기는 유한, 생산자는 버퍼가 가득 차면 더 넣을 수 없고 소비자는 버퍼가 비면 뺄 수 없다.
- 잘못된 결과 : 실행 불가 또는 생산된 항목 숫자와 소비된 항목 숫자 다름. 최종적으로 버퍼에 0개가 있어야 한다.
  - 이유 : 공통변수 count, buff[]에 대한 동시 업데이트로 공동변수 업데이트 구간(임계구역)에 동시 진입
  - 해결법 : 임계구역에 대한 동시 접근 방지(상호 배타), 임계구역 전에 mutex.acquire() 끝나고 murtex.release()
  - Busy-wait : 생산자를 위한 빈 공간, 소비자를 위한 찬 공간이 있어야한다. 기다리는 동안 cpu가 계속 조건을 체크하면서 무한루프 하는데 이게 busy-wait고 좋지 않다. 낭비를 없애기 위해 버퍼가 꽉 차 있으면 무한 루프가 아니라 세마포 감옥에 가두기.


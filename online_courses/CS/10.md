### 1. 프레임 할당 Allocation of Frames

- 쓰레싱(Thrashing)

  - CPU utilization(CPU 활용률) vs Degree of multiprogramming(메모리에 프로세스 개수가 몇 개 올라와 있는지) : 프로세스 개수가 많아질수록 CPU 활용률도 높아질거라고 생각한다. 그런데 Demand paging을 적용해보니 프로세스 개수에 따라 활용률이 높아지다가 어느 지점에서 하락하게 된다. 이유는 빈번한 page in/out 때문에. 
  - thrashing: 하락하는 지점을 말한다. i/o 시간 증가 때문에 생김.
  - 극복 : global replacement보다 local로, 프로세스당 충분한, 적절한 수의 메모리(프레임) 할당. 적절함이 얼마 정도인지 어떻게 알까?
    - 정적인 방법 : 프로세스 크기에 맞춰서 할당
      - equal allocation : 동일 할당, 우리가 올리려는 프로세스가 3개라면 전부 동일하게 프레임을 나눠준다. (100개라면 셋한테 33개씩). 그런데 큰 애나 작은 애나 같은 양을 받으므로 부적절.
      - proportional allocation: 비례 할당, 프로세스 크기에 따라 나눠주기. 그러나 크기 커도 특별히 어려운 기능을 쓰지 않을 때가 많다.(한글에서 문서 편집만 하지 표만들기는 잘안하니까)
    - 동적인 방법
      - working set
      - page fault frequency




### 2. 파일 할당 File Allocation

- 컴퓨터 시스템 자원 관리
  - CPU : 프로세스 관리(CPU 스케줄링, 프로세스 동기화)
  - 주기억장치 : 메인 메모리 관련(페이징, 가상 메모리)
  - 보조기억장치 : 파일 시스템
- 보조기억장치(하드 디스크)
  - 하드디스크 : track(앞 뒷면이 있다), cylinder(하드 디스크 안에 트랙이 여러개 있는데 같은 거리에 있는 트랙들의 집합을 말한다), sector(트랙을 하나하나 자른것)
  - sector size : 512 byte, 섹터 여러 개 모은게 block
  - 하드 디스크에 뭘 읽고 쓸 때 블록 단위의읽기/쓰기 그래서 하드 디스크는 block device, 반대는 character device(키보드) / 메모장에 한글자만 쓰고 저장해도 block크기만큼 저장된다. 한바이트만 썼어도 4키로바이트가 저장됨
  - 디스크 : pool of free blocks 하드 디스크는 여러 블록으로 나뉘어졌다.
  - 각각의 파일에 대해 free block을 어떻게 할당해줄까?

- 연속할당 Contiguous Allocation
  - 각 파일에 대해 디스크 상의 연속된 블록을 할당. 장점은 디스크 헤드 이동 최소화로 빠른 i/o 성능. 6~70년대 사용. 동영상같은 큰 파일을 사용할 때 좋다. 순서적으로 읽을 수 있고(순차접근 sequential access) 특정 부분을 바로 읽을 수도 있다 (직접접근 direct access)
  - 각각의 파일은 정보를 기록해둔 디렉토리Directory가 있다. 만들어진 시간, 소유자 등 우리에게 보이는 정보가 있고 시작 블록 같은 안보이는 정보도 기록되어 있다. 디렉토리에 정보가 있으니까 직접접근이 가능하다.
  - 사용되지 않는 이유 : 파일을 지울 경우 문제가 발생한다. 블록에서 파일이 있던 자리는 비게 된다. 하드 디스크 중간중간 빈 자리hole가 있는데, first-fit, best-fit 공부했을 때 봤던 외부 단편화가 발생할 가능성이 있다. 남은 용량 합치면 넣을 수 있는데 빈 공간이 떨어져있어서 못넣기 때문에 디스크 공간 낭비가 생긴다. Compaction 할 수 있지만 시간이 오래 걸린다(MS-DOS)
  - 또 다른 단점 : 파일 생성 다시 파일의 크기를 알 수 없다. 어느 hole에 넣을지? (처음에 한글 파일 생성할 때 크기는 모르게 작업을 하니까), 파일 크기가 계속 증가할 수 있다.
- 연결할당 Linked Allocation
  - 파일 = linked list of data blocks
  - 파일 디렉토리는 제일 처음 블록 가리킨다. 
  - 각 블록의 포인터 저장을 위해 4바이트 이상 사용
  - 새로운 파일 만들기 : 비어있는 임의의 블록을 첫 블록으로, 파일이 커지면 다른 블록을 할당 받고 연결. 외부 단편화 없음.
  - 단점 : 포인터를 따라 다음으로 가야하니까 직접접근을 못하고 순차접근 해야함. 동영상 중간부터 못 봄. 포인터 저장 위해 4바이트 손실, 낮은 신뢰성(포인터 끊어지면 그 다음 접근 불가), 느린 속도(헤더의 움직임, 파일이 흩어져있으니까.)
  - 개선 : FAT 파일 시스템 File Allocation Table, 포인터들만 모은 테이블을 별도 블록에 저장, 손실 시 복구를 위해 이중 저장. dircet access도 가능하게 해줌(f1의 3번째 블록을 읽고싶다? 해도 다 어딘지 저장되어 있음). 일반적으로 메모리 캐싱. 신뢰성도 높아짐.
- 색인할당 Indexed Allocation
  - 파일 당 (한 개의) 인덱스 블록 - 데이터 블록 외에. 파일을 블록으로 여기저기 저장하고 어디에 저장되어 있는지 정보를 저장하는 블록을 따로 둔다.(인덱스 테이블)
  - 인덱스 블록은 포인터의 모음, 디렉토리는 인덱스 블록을 가리킨다. unix, linux 등에서 사용
  - 장점 : 직접접근 가능, 외부 단편화 없음
  - 단점 : 인덱스 블록 할당에 다른 저장공간 상실. 한 글자 저장해도 인덱스 블록이 따로 생김.
  - 파일의 최대 크기 : 한블록이 512바이트면 4바이트 * 128개 인덱스. 한 파일당 128개면 파일당 64키로바이트까지만 됨. (128 * 512바이트 = 64kb) / 해결방법 : linked, multilevel index, combined 등
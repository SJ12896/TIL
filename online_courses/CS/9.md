### 1. 요구 페이징

- 유효 접근 시간 Effective Access Time : 필요없는거 메인 메모리에 지금 안올라와있어서 빨리 못읽음. 근데 또 어떤애는 미리 올라와있어서 바로 읽을 수 있음. 이런 걸 전부 합친 평균 시간을 말한다. 또 이 때 바로 읽을 수 있어서 page fault가 일어나지 않는 확률도 구할 수 있따.

- 대부분의 시간은 하드디스크 읽는데 시간이 소요된다.(seek time)
- 하드디스크 : 원판에 자성물질 -> 전기 호일을 감아서 전기를 흘리면 n극과 s극이 바뀌면서 값을 저장...(?) 읽을 때도 전기를 보내서 읽음 (?)
- 디스크 헤드를 우리가 원하는 헤드로 옮겨서 원하는 정보를 얻는데 걸리는 시간 seek time + 헤드 밑까지 오는데 걸리는 시간 rotational delay + 전기가 유도되어지면서 읽는 시간 transfer time = 걸리는 시간

- 지역성의 원리 
  - Locality of reference : 메모리 접근은 시간적, 공간적 지역성을 가진다. 실제 페이지 부재 확률은 매우 낮다. cpu가 참조하는 주소는 local하다(특정 지역에 모여있다.)
  - 다른 방법 : HDD는 접근시간이 너무 길어서 swap device로 부적합. SSD 또는 느린 저가 DRAM 사용



### 2. 페이지 교체 Page Replacement

- Demand Paging : 요구되는 페이지만 backing store에서 가져온다. 프로그램을 실행하면 계속 요구 페이지가 늘어나서 언젠가는 메모리가 가득 찬다.
- Memory full : 메모리가 가득 차면 추가로 페이지를 가져오기 위해 어떤 페이지는 backing store에서 몰아내고(page-out, victim page) 그 빈공간으로 페이지를 가져온다(page-in)
- Victim Page
  - 원래 하드디스크에 있다가 메인 메모리에 올라왔을 때 내용이 수정되지 않았다면다시 돌아갔을 때 딱히 write를 할 필요 없다. 그래서 희생양을 정할 때 시간을 절약하기 위해 최대한 write를 적게 하는 걸로 고른다. 
  - 정하는 방법? Random, FIFO, 페이지 교체 알고리즘
- 페이지 교체 알고리즘
  - Page reference string : cpu가 내는 주소가 101, 102, 432, 103, 611일 때 page size가 100바이트면 페이지 번호는 1, 1, 4, 1, 6이다. page reference string은 1, 4, 1, 6인데 연속 페이지면 읽고 있던 중이기 때문에 page fault가 일어나지 않기 때문이다. 
  - FIFO
  - OPT(optimal)
  - LRU(Least-Recently-Used)


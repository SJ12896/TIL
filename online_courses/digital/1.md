## 1. 들어가기

### 1-1. 디지털 신호와 아날로그 신호

- 아날로그 신호 Analog Signal: 자연계에서 일어나는 물리적인 양은 시간에 따라 연속적으로 변화. 온도, 습도, 소리, 빛 등
- 디지털 신호Digital Signal : 분명히 구별되는 두 레벨의 신호값 만을 갖는다.
- 디지털 시스템 : 이산입력 -> 이산출력. 이산적인 정보를 가공하고 처리해서 최종 목적으로 하는 정보를 출력하는 모든 형태의 장치
  - 장점 : 내, 외부 잡음에 강함. 설계 용이. / 프로그래밍으로 전체 시스템을 제어할 수 있어 규격이나 사양 변경에 쉽게 대응, 기능 구현의 유연성. / 정보 저장과 가공에 용이. / 아날로그에서 다루기 어려운 비선형 처리나 다중화 처리도 가능. / 소형화, 저가격화 가능. / 정보 처리 정확성과 정밀도 높일 수 있음.
- 아날로그 시스템 : 연속입력 -> 연속출력. 연속적인 정보를 입력받아 처리해서 연속적인 형태의 정보를 출력하는 시스템
- 아날로그 입력에서 A/D converter를 통해 디지털 출력 가능. 반대의 경우는 D/A converter를 통해 가능

### 1-2. 디지털 정보의 표현

- 디지털 정보를 표현하기 위해 2진수 체계binary system를 사용
- 0, 1만의 2종류 디지트(digit) 사용
- 1nibble = 4bit
- 1byte = 8bit
- 1byte = 1character
- 1word = 특정 CPU에서 취급하는 명령어나 데이터 길이에 해당하는 비트 수
- 영어는 1byte 1문자, 한글은 2byte 1문자

<br/>

## 2. 수의 체계

- 16진수 : 10부터 15까지 A ~F로 표현
- 10진수 -> 2진수 변환 소수부분 : 소수부분만 따로 떼서 2를 곱한다. 곱셈결과 정수부분이 나오면 정수부분을 소수점 뒤에 적는다.(1, 0) 소수부분이 0이 될 때 까지 계속한다.
- 10진수 -> 2진수 변환 소수부분 : 소수부분만 떼로 떼서 2를 곱한다. 똑같이 정수부분을 따로 뗴서 소수점 뒤에 적는데 결과가 무한히 계속 될 수도 있다.
- 2진수 -> 8진수 변환 : 3자리씩 끊어서 계산한다. 2진수 1000101.1011이 있다면 1 / 000 / 101 / . 101 / 1로 끊는다. 부족한 부분은 0으로 채운다.
- 2진수 -> 16진수 : 4자리씩 끊어서 계산한다. 마찬가지로 부족한 부분은 0으로 채운다.

### 2-1. 2진 정수 연산과 보수

- 2진수에서 1+1은 10으로 자리올림이 발생한다.
- 최상위 비트(MSB)를 부호비트로 사용. 양수 0, 음수 1
- 2진 음수 표현법 : 부호와 절대치, 1의 보수, 2의 보수
  - 양수일 때는 저 세 방법이 동일하다.
  - 부호와 절대치, 1의 보수는 -0을 가진다. 
  - 컴퓨터 내부에선 2의 보수에 의한 방법으로 처리한다.
- 1의 보수로 변환하는 방법 : 0 -> 1, 1 -> 0
- 2의 보수로 변환하는 방법 : 1의 보수 + 1
- r진법 n자릿수 x의 r의 보수 : rⁿ-x
- r진법 n자릿수 x의 r의 보수 : rⁿ-1-x

- 양수를 보수로 바꾸면 음수, 음수를 보수로 바꾸면 양수

- 뺄셈은 보수를 취하여 더하는 방식으로 실행된다. 자리 올림(Carry)이 있으면 버림.
- 부호 확장 : 늘어난 비트 수 만큼 부호를 늘려주는 방법.
  - 부호와 크기 : 부호만 MSB에 복사하고 나머지는 0으로 채움.
  - 1의 보수와 2의보수 : 늘어난 길이만큼 부호와 같은 값으로 모두 채움(양수0, 음수 1)
- 2의 보수로 표현된 음수를 10진수로 변환하기
  - MSB가 1이면 음수. 그 부분만 -로 계산하고 나머지는 그대로 계산
  - 2의 보수로 바꾸어 10진수로 바꾼 다음 -부호 붙이기(더 많이 사용)
- 2의 보수연산에서 계산 후 MSB자리에 침범해 결과 값의 맨 앞 부분이 달라져서 답의 부호가 바껴버리면 overflow

- [[어셈블리어] 정수의 음수표현과 캐리 & 오버플로우 - (carry and overflow)](https://man-25-1.tistory.com/60)
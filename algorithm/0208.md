## APS(Algorithm Problem Solving)

- APS 과정의 목표 중 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것(정확성, 작업량, 메모리 사용량, 단순성, 최적성)



### 배열 1(Array 1)

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 알고리즘의 작업량은 시간 복잡도로 표현

  - 시간 복잡도 : 실제 걸리는 시간 측정, 실행되는 명령문의 개수 계산, 빅-오(O) 표기법

  - 빅-오 표기법 : 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시, 계수는 생략

    - O(2n² +10n+100) = O(n²)

    

- 배열 : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



- 버블 정렬(Bubble Sort) : 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식 / O(n²)

```python
N = int(input())
data = []

for i in range(N):
    data.append(int(input()))

# list의 맨 마지막은 가장 큰 값이 정렬되는 곳으로 그 앞이 최종 비교하는 자리다. 맨 마지막이 가장 큰 숫자로 정렬되고 나면 차례로 그 앞 위치를 그 다음 큰 숫자로 정렬한다.
for i in range(N-1, 0, -1):
    # list 시작부터 그 뒤에 위치한 숫자와 비교하면서 큰 쪽을 뒤로 보내는데 이미 정렬된 숫자는 비교할 필요가 없다.
    for j in range(i):
        if data[j] > data[j+1]:
            data[j], data[j+1] = data[j+1], data[j]

for i in data:
    print(i)
```



- 카운팅 정렬(Counting Sort) : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘. 

  - 제한사항 : 정수나 정수로 표현할 수 있는 자료에만 적용 가능. 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문이다. 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
  - O(n+k) : n은 리스트 길이, k는 정수의 최대값

  

- **완전검색 **: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다. Brute-force, Generate-and-Test 기법이라고도 불린다. 모든 경우의 수를 테스트하고 최종 해법을 도출한다. 경우의 수가 상대적으로 작을 때 유용하다.

- 그리디(Greedy Algorithm) : 최적해를 구하는 근시안적인 방법. 그 순간 최적이라고 생각되는 것을 선택한다. 

- 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것. 서로 다른 n개 중 r개를 택하는 순열  nPr

- nPr = n * (n-1) * (n-2) * ... * (n-r+1)




## APS(Algorithm Problem Solving)

- APS 과정의 목표 중 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것(정확성, 작업량, 메모리 사용량, 단순성, 최적성)



### 배열 1(Array 1)

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 알고리즘의 작업량은 시간 복잡도로 표현

  - 시간 복잡도 : 실제 걸리는 시간 측정, 실행되는 명령문의 개수 계산, 빅-오(O) 표기법

  - 빅-오 표기법 : 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시, 계수는 생략

    - O(2n² +10n+100) = O(n²)

    

- 배열 : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조



- 버블 정렬(Bubble Sort) : 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식 / O(n²)

```python
N = int(input())
data = []

for i in range(N):
    data.append(int(input()))

# list의 맨 마지막은 가장 큰 값이 정렬되는 곳으로 그 앞이 최종 비교하는 자리다. 맨 마지막이 가장 큰 숫자로 정렬되고 나면 차례로 그 앞 위치를 그 다음 큰 숫자로 정렬한다.
for i in range(N-1, 0, -1):
    # list 시작부터 그 뒤에 위치한 숫자와 비교하면서 큰 쪽을 뒤로 보내는데 이미 정렬된 숫자는 비교할 필요가 없다.
    for j in range(i):
        if data[j] > data[j+1]:
            data[j], data[j+1] = data[j+1], data[j]

for i in data:
    print(i)
```



- 카운팅 정렬(Counting Sort) : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘. 

  - 제한사항 : 정수나 정수로 표현할 수 있는 자료에만 적용 가능. 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문이다. 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
  - O(n+k) : n은 리스트 길이, k는 정수의 최대값

  

- **완전검색 **: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다. Brute-force, Generate-and-Test 기법이라고도 불린다. 모든 경우의 수를 테스트하고 최종 해법을 도출한다. 경우의 수가 상대적으로 작을 때 유용하다.

- 그리디(Greedy Algorithm) : 최적해를 구하는 근시안적인 방법. 그 순간 최적이라고 생각되는 것을 선택한다. 

- 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것. 서로 다른 n개 중 r개를 택하는 순열  nPr

- nPr = n * (n-1) * (n-2) * ... * (n-r+1)



### 배열 2(Array 2)

- 배열 : 2차 배열

  - 2차원 배열로 생성하는 방법 : 1) 먼저 빈 리스트를 만든다. 행의 길이를 입력 받고 for문을 사용해 list형태로 append. 2) [0]*N을 만든 뒤 해당 위치에 리스트 3) arr = [list(map(int, input().split())) for _ in range(N)]
  - 지그재그 순회 : Array[ i [ j+(m-1-2*j) * (i%2)], m은 열의 길이
  - 델타를 이용한 2차 배열 탐색 : 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법. dx = [-1,1,0,0], dy=[0,0,-1,1] #상하좌우의 좌표
  - 전치 행렬

  > 선형대수학에서, 전치 행렬은 행과 열을 교환하여 얻는 행렬이다. 즉, 주대각선을 축으로 하는 반사 대칭을 가하여 얻는 행렬이다. [위키백과](https://ko.wikipedia.org/wiki/전치행렬)

  ```python
  for i in range(3):
      for j in range(3):
          if i < j: # 조건을 지정하지 않으면 바뀐 자리가 다시 원래대로 돌아가면서 처음 배열 그대로
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
  ```

  

- 부분집합 생성 : 완전검색 기법에서는 우선 모든 부분집합을 생성해야 한다.

  - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2ⁿ개이다.

  - 각 원소를 부분집합에 포함시키거나 시키지않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

  - 비트 연산자

    - << : 한 번 하면 값이 2배로 늘어남, >> : 2배 줄어듦

    - << : 1 << n : 2ⁿ 원소가 n개일 경우의 모든 부분집합 수를 의미
    - & : i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 리턴, (6 & (1 << 1) ex : 0110과 0001을 비교)

    ```python
    arr = [3,6,7,1]
    n = len(arr)
    for i in range(1<<n): # 모든 부분집합의 개수만큼
        for j in range(n+1): # 모든 원소의 수만큼 비트를 비교하고 j는 각 원소를 접근하는 index
            if i & (1<<j): # i의 j번째 비트가 1이면 j번째 원소 출력
                print(arr[j], end = ", ")
        print()
       
    
    3, 
    6, 
    3, 6, 
    7, 
    3, 7, 
    6, 7, 
    3, 6, 7, 
    1, 
    3, 1, 
    6, 1, 
    3, 6, 1, 
    7, 1, 
    3, 7, 1, 
    6, 7, 1, 
    3, 6, 7, 1, 
    ```



- 검색 : 목적하는 탐색 키(자료를 구별하여 인식할 수 있는 키)를 가진 항목을 찾는 것
  
- 순차 검색 : 일렬로 되어 있는 자료를 순서대로 검색하는 방법. 정렬되지 않은 자료에서 순차 검색 평균 비교 회수는 (n+1)/2. 정렬되어 있을 경우 찾는 값보다 비교하는 값이 커지면 없다는 의미이므로 중지. 평균 비교 회수가 반으로 줄어드는데 시간 복잡도는 둘 다 같다. O(n), 최악의 경우에나 n이 커지면 그게 그거라서
  
- 바이너리 서치(이진 검색) : 자료의 가운데 있는 항목의 키 값과 비교해 다음 검색의 위치를 결정하고 검색을 계속 진행함. 목적 키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가며 빠르게 검색 수행함. 이진 검색을 하기 위해서는 **자료가 정렬된 상태**여야 한다.
  - 자료의 중앙에 있는 원소를 고른다 -> 목표값과 비교한다. -> 목표 값이 중앙 원소 값보다 작으면 왼쪽 반에 대해서 새로 검색을 수행하고 크다면 자료의 오른쪽 반에 대해 새로 검색을 수행한다. -> 찾고자 하는 값을 찾을 때 까지 앞의 과정을 반복한다.
  - 자료에 삽입이나 삭제가 발생했을 때 항상 정렬 상태로 유지하는 추가 작업 필요
  - 재귀 함수를 이용해 구현할 수 있다.

- 셀렉션 알고리즘(선택 정렬) : 저장된 자료부터 k번째 큰 혹은 작은 원소를 찾는법. 시간복잡도 O(n²)

  - 주어진 리스트 중 `최소값을 찾는다` -> 그 값을 리스트의 맨 앞에 위치한 값과 교환한다. -> 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
  - 교환 회수가 버블, 삽입보다 작다.

  


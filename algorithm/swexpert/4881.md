### 4881_배열 최소 합

> NxN 배열에 숫자가 들어있다. 한 줄에서 하나씩 N개의 숫자를 골라 합이 최소가 되도록 하려고 한다. 단, 세로로 같은 줄에서 두 개 이상의 숫자를 고를 수 없다.
>
> 조건에 맞게 숫자를 골랐을 때의 최소 합을 출력하는 프로그램을 만드시오.
>  
>
> 예를 들어 다음과 같이 배열이 주어진다.
>  
>
> | 2    | 1    | 2    |
> | ---- | ---- | ---- |
> | 5    | 8    | 5    |
> | 7    | 2    | 2    |
>
> 
>
> 이경우 1, 5, 2를 고르면 합이 8로 최소가 된다.
>
>  
>
> **[입력]**
>  
>
> 첫 줄에 테스트 케이스 개수 T가 주어진다. 1≤T≤50
>  
>
> 다음 줄부터 테스트 케이스의 첫 줄에 숫자 N이 주어지고, 이후 N개씩 N줄에 걸쳐 10보다 작은 자연수가 주어진다. 3≤N≤10
>
>  
>
> **[출력]**
>  
>
> 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 합계를 출력한다.



- N-Queen 문제를 힘들게 푼 후 비슷한 유형이라고 생각해서 똑같이 풀었지만 마찬가지로 런타임 에러를 겪고 바꿨다. 비슷해보이지만 다른 문제인데 앞서 풀었던 문제를 기억해서 똑같이 풀려고 한 걸 보면 너무 한 가지 사고의 틀에 갇혀서 문제를 바라보는 느낌이다.
- 가지치기라는 개념 자체에 대해 더 잘 이해할 필요가 있어보인다.

```python
T = int(input())

def dfs(i):
    global result, temp

    if i == N:
        if temp < result:
            result = temp
            return

    # 여기가 바로 가지치기 지점이다.
    if temp > result:
        return

    for j in range(N):
        if j not in col:
            col[i] = j
            temp += arr[i][j]
            # 이 중간함수를 통해 끝까지 간다. 
            dfs(i + 1)
            # 이 부분이 많이 이해가 안가서 헤맸다. 빠져 나오면서 temp 값을 원래대로 되돌리고
            temp -= arr[i][j]
            # 각 열에 어디 위치했는지 표시하는 리스트도 원래대로 되돌린다.
            col[i] = -1
# 원래 값으로 되돌리는 이유는 재귀를 통해 i번째, i+1번째, i+2번째 까지 다 간 이후에 다시 앞선 행으로 되돌아온 뒤 그 다음 열에서 시도해야되기 때문이다. 이 부분이 헷갈렸다는 건 재귀에 대한 이해가 좀 낮은 듯 하다.

for tc in range(1, T+1):
    N = int(input())
    arr = []
    for i in range(N):
        arr.append(list(map(int, input().split())))

    col = [-1] * N

    i = 0
    temp = 0
    result = 100
    dfs(i)
    print("#{} {}".format(tc, result))
```


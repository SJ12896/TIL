### 1216_회문2

> **[제약사항]**
>
> 각 칸의 들어가는 글자는 c언어 char type으로 주어지며 'A', 'B', 'C' 중 하나이다.
>
> 글자 판은 무조건 정사각형으로 주어진다.
>
> ABA도 회문이며, ABBA도 회문이다. A또한 길이 1짜리 회문이다.
>
> 가로, 세로 각각에 대해서 직선으로만 판단한다. 
>
> **[입력]**
>
> 각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.
>
> 총 10개의 테스트케이스가 주어진다.
>
> **[출력]**
>
> \#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 찾은 회문의 길이를 출력한다.



- 회문은 전부 어렵다. 막상 풀고나면 그렇게 어렵지는 않은데 구상할 때 머리가 이런 저런 변수를 많이 사용하다보니 머리가 정돈되지 않는 느낌이다.

```python
T = 10

for tc in range(1, T+1):
    n = int(input())
    graph = []
    # 100 * 100 글자판에서 가로 세로 모두 봐서 가장 긴 회문 길이
    for i in range(100):
        graph.append(list(input()))

    # 가장 긴 회문 길이를 구한다.
    max_cnt = 0
    # k는 행의 위치를 알기위해 사용했다.
    for k in range(100):
        # i는 한 행에서 문자열이 시작되는 곳이다.
        for i in range(100):
            # j는 문자열의 끝이다. 여기서 j는 i를 시작점으로 해서 리스트 끝까지 늘어난다. 또 인덱싱이 아니라 슬라이싱을 사용하기 때문에 리스트 크기에 +1을 했다.
            for j in range(i, 100+1):
                # 첫번째 string은 한 행에서 i부터 j까지의 글자다.
                string = graph[k][i:j]
                # 두번째 string은 열을 기준으로 한다. 여기서는 k값이 행의 위치가 아니라 고정된 열의 위치를 나타내는데 사용했다. 첫번째 string이 i부터 j까지인데 여기서는 슬라이싱이 아니라 인덱싱을 사용했다.
                string2 = [graph[a][k] for a in range(i, j)]
			   # 먼저 첫 번째 스트링을 뒤집고 그 결과가 원래 스트링과 같으면 문자열 길이를 센다. 두 번째 스트링에도 같은 작업을 한다.
                if string == string[::-1]:
                    if (j-i) > max_cnt:
                        max_cnt = (j-i)
                if string2 == string2[::-1]:
                    if (j-i) > max_cnt:
                        max_cnt = (j-i)

    print("#{} {}".format(tc, max_cnt))
```


### 11315_오목 판정

> N X N 크기의 판이 있다. 판의 각 칸에는 돌이 있거나 없을 수 있다. 돌이 가로, 세로, 대각선 중 하나의 방향으로 다섯 개 이상 연속한 부분이 있는지 없는지 판정하는 프로그램을 작성하라.
>
>  
>
> **[입력]**
>
> 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에는 하나의 정수 N(5 ≤ N ≤ 20)이 주어진다.
>
> 다음 N개의 줄의 각 줄에는 길이 N인 문자열이 주어진다. 각 문자는 ‘o’또는 ‘.’으로, ‘o’는 돌이 있는 칸을 의미하고, ‘.’는 돌이 없는 칸을 의미한다.
>
>  
>
> **[출력]**
>
> 각 테스트 케이스 마다 돌이 다섯 개 이상 연속한 부분이 있으면 “YES”를, 아니면 “NO”를 출력한다.



- 처음 시작할 때 해결방향을 잘못잡는 경우가 너무 많다. 문제 보고 떠오른 첫 아이디어를 바로 구현하지 말고 문제를 더 살펴야겠다. ooooo가 있으니까 패턴매칭으로 틀린 부분이 나왔을 때부터 다시 구해야겠다고 생각했는데 이게 가로, 세로 방향까지는 잘 맞았지만 대각선이 틀렸다. 대각선에서도 구현은 가능하지만 대각선 시작 방향이 끝점이 아니라 중간부터 시작하는 경우를 고려하지 않았다. 그래서 계속 첫 번째 아이디어를 고수하느라 고치다가 시간을 날리고 델타를 이용한 2차 배열 탐색으로 가야했다. 앞서 풀었던 달팽이 문제도 델타를 이용해야했는데 그 문제도 생각을 못해서 굉장히 오래걸렸다. 델타와 함수를 만들어 사용하는 부분에서 많이 미흡하다는 생각이 든다.

```python
import sys
sys.stdin = open("input.txt")

T = int(input())
# 오른쪽, 오른쪽아래, 아래, 왼쪽아래
dx = [0, 1, 1, 1]
dy = [1, 1, 0, -1]

def search(graph, N):
    # 행
    for i in range(N):
        # 열
        for j in range(N):
            # dir은 내장함수니까 다음부터 다른 이름을 쓰도록 하자.
            # 네 방향을 지정하기 위해 사용했다.
            for dir in range(4):
                # o의 수
                cnt = 0
                # x, y 좌표는 i,j 값이 처음 기준으로 잡고 이동하면서 연속된 o를 찾는다.
                x, y = i, j
                # 그래프 밖으로 나오면 while문 중단
                while x >= 0 and y >= 0 and x <= N - 1 and y <= N - 1:
                    # o를 만나면 1이 증가한다.
                    if graph[x][y] == 'o':
                        cnt += 1
                    # 연속된 5개의 o를 충족하지 못했으므로 중단
                    else:
                        break
			       # 연속된 o를 찾으면 끝. 5개 이상이니까 5개만 찾아도 끝
                    if cnt == 5:
                        return 'YES'
                    # dx, dy를 기준으로 이동해 나간다.
                    x += dx[dir]
                    y += dy[dir]
    return 'NO'

for tc in range(1, T+1):
    N = int(input())

    graph = []
    for i in range(N):
        graph.append(list(input()))
    
    print("#{} {}".format(tc, search(graph, N)))
```


### 3752_가능한 시험 점수

> 영준이는 학생들의 시험을 위해 N개의 문제를 만들었다.
>
> 각 문제의 배점은 문제마다 다를 수 있고, 틀리면 0점 맞으면 배점만큼의 점수를 받게 된다.
>
> 학생들이 받을 수 있는 점수로 가능한 경우의 수는 몇 가지가 있을까?
>
> 예를 들어, 첫 번쨰 Testcase의 경우, 총 문제의 개수는 3개이며 각각의 배점은 2, 3, 5점이다
>
> 가능한 시험 점수의 경우의 수를 살펴보면 0, 2, 3, 5, 7, 8, 10의 7가지가 있다.
>
> 두 번째 Testcase의 경우, 총 문제의 개수는 10개이며 각각의 배점은 모두 1점이다.
>
> 가능한 시험점수의 경우의 수를 살펴보면 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10으로 모두 11가지이다.
>
> 
> **[입력]**
>
> 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에는 자연수 N(1 ≤ N ≤ 100)이 주어진다.
>
> 두 번째 줄에는 각 문제의 배점을 의미하는 N개의 자연수가 공백으로 구분되어 주어진다. 배점은 1이상 100이하의 자연수이다.
>
> **[출력]**
>
> 각 테스트 케이스마다 학생들이 받을 수 있는 점수의 경우의 수를 출력한다.



- combinations -> runtime error 실패 (메모리 초과인듯?)

- dfs -> 시간 초과 실패 (100 * 100 하면 최대 값이 10000이라서... 그런가봄)
- 결국 dp스러운 무언가를 힌트로 보고 풀었다. dp라고 해도 되나? 근데 솔직히 비슷한 유형 풀 때 생각해낼 수 있을까 의문이 든다.
- 가능한 점수 값을 기준으로 for문 시작. 가능한 점수와 더하는 결과 점수값은 0만 존재하기 때문에 가능한 점수 값 초기값이 들어간다. 그리고 2번째 score부터는 앞선 점수값에 더한 값이 들어간다. 겹치는 점수가 있었는지 확인하기 위해 visited를 활용했다. 두 번째 값 for문 실행 후에 결과 점수값에 0, 1, 2, (1+2)가 들어가있고 그 다음 3번을 실행하면 0, 1, 2, 3, 1+2+3, 1+3, 2+3이 들어가있게 된다. 특정 index를 띄엄띄엄 더해주기 때문에 dfs를 써야한다고 생각했다. 하지만 dp처럼 index에 값을 누적시키지않고 결과값 리스트에 따로 값을 누적해서 거기에 전부 더하는 방식을 활용하면 됐다.

```python
import sys
sys.stdin = open("input.txt")

T = int(input())

for tc in range(1, T+1):
    N = int(input())
    scores = list(map(int, input().split()))

    visited = [1] + [0] * (sum(scores) + 1)

    sum_scores = [0]
    for score in scores:
        temp = []
        for i in sum_scores:
            if not visited[score+i]:
                visited[score + i] = 1
                temp.append(score + i)
        sum_scores.extend(temp)

    print("#{} {}".format(tc, sum(visited)))

```


## 스택1

- 스택 : 물건을 쌓아 올리듯 자료를 쌓아 올린 자료구조. 저장된 자료는 선형구조(자료간 관계가 1대1, 비선형구조는 1대N으로 트리같은거). 마지막에 삽입한 자료를 가장 먼저 꺼낸다.(LIFO)
  - 자료구조 : 자료를 선형으로 저장할 저장소, 저장소 자체를 스택이라고 부르기도 한다.
  - 스택에서 마지막 삽입된 원소의 위치를 top이라고 부른다.
  - 연산 : 삽입(push), 삭제(pop -> 스택에 값이 없을 때에 대한 처리 잘해주기. 걍 return), 공백인지 확인(isEmpty), top에 있는 원소 반환(peek)
  - 응용 : 괄호검사 -> 왼, 오 괄호개수가 같아야 한다. 같은 괄호에서 왼쪽 괄호는 오른쪽보다 먼저 나와야 한다. 괄호 사이에는 포함관계만 존재한다. / pop해서 비교.
    - 문자열 괄호를 조사해서 왼쪽을 만나면 스택 삽입, 오른쪽을 만나면 top을 삭제 후 짝이 맞는지 검사
    - 스택이 비어있거나 괄호 짝이 맞지 않으면 조건 위배
    - 마지막까지 조사 후 스택에 괄호가 남아있어도 위배
  - 응용2: function call -> 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리. 가장 마지막에 호출된 함수가 가장 먼저 실행 완료. 실행이 끝나면 시스템 스택의 top이 pop. 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택 ex)전에 배웠던 재귀, 이미 많이 사용했던 list(map(int, input().split()))도 해당된다.
  - stack을 클래스로 만들고 그 안에 연산을 만들 수도 있다.



- Memoization
  - 재귀함수를 구현할 경우 중복 호출이 엄청난데 이걸 방지하기 위해 Memoization을 사용한다.
  - 이전에 계산한 값을 메모리에 저장해 전체 실행속도를 빠르게 한다.
  - 동적 계획법의 핵심이 되는 기술(DP)
  - 미리 리스트에 길이만큼 저장공간을 -1값으로 만들어뒀다가 호출할 때 값이 -1이면 값을 바꾸는 방식 or 그냥 0,1값만 만들어놓고 append하는 방식이 있다.



- DP(Dynamic Programming)
  - 그리디 알고리즘처럼 최적화 문제를 해결하는 알고리즘
  - 입력 크기 작은 부분들을 모두 해결한 후 그 해들을 이용해 보다 큰 크기의 부분 문제를 해결해 최종적으로 원래 주어진 입력의 문제 해결
  - 메모이제이션은 재귀적 구조보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다. 재귀적 구조는 내부 시스템 호출 스택을 사용해 오버헤드가 발생한다.



- **DFS(깊이우선탐색)**
  - 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다. 그래서 내가 방문한 곳을 기록하기 위해 stack을 사용한다. => DFS, BFS
  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈곳이 없으면 마지막 갈림길이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색 반복해 결국 모든 정점 방문
  - 가장 마지막 갈림길로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용
  - 시작 정점 v를 결정해 방문 -> 정점 v의 인접한 정점에서 방문하지 않은 w가 있다면 v를 스택에 push, w를 방문 -> w를 v로 하여 다시 반복 -> 방문하지 않은 정점이 없다면 방향을 바꾸기 위해 pop해 가장 마지막 방문 정점을 v로 해 다시 반복 -> 스택이 공백이 될 때 까지 반복
  - 방문했는지 체크하는 visited(0은 제외하고), 왔던 길을 기록하는 stack. 이 때 인접리스트를 활용해 현재 있는 노드에선 더 갈 곳이 없다는 걸 알면 stack에서 pop하고 마지막 값으로 돌아간다.
  - 방문하지 않은 정점이 여러개면 뭘 먼저 방문할까? 알아서. 보통 이동에 규칙이 없다.
  - `인접행렬` : 그래프 노드 수만큼 행, 열을 가진 2차원 리스트를 만든다. 1과 2가 연결되어있다면 방향에 따라 단방향이면 (1,2)만 1로 바꾸고 (2,1)은 0으로 두는식으로 체크한다. 보통 자신에서 자신으로 가진 않으니까 대각선 방향은 0이다. 이걸 사용해서 인덱스접근을 할때 i+1을 하게 되는데 불편하니까 왼쪽과 위쪽에 열, 행을 하나씩 추가하면 편하다. 반복문 도는 횟수가 인접리스트보다 많다.
  - `인접리스트` : 연결된 정점들만 넣는다. 이것 역시 사용되지않는 0행의 리스트는 비어있고 1부터 1번 노드에 연결된 노드를 추가한다. 방향에 따라 단방향이면 1에만 2를 넣는다.



## 스택2

- 계산기 : 문자열로 된 계산식 주어지면 스택 사용해 계산. 중위 표기법의 수식을 후위 표기법으로 스택 이용해 변경한다 => 무조건 스택으로 풀어야하는 획일화된 문제기 때문에 자주 등장하지는 않는다.

  - 중위표기법 : 연산자를 피연산자 가운데 표기
  
  - 후위 표기법 : 연산자를 피연산자 뒤에 표기 (ex: AB+)
  
  - 후위 표기법 스택 계산 : 피연산자 만나면 push, 연산자 만나면 pop해서 연산, 결과 다시 push. 끝나면 마지막으로 pop

  - 중위 -> 후위 변환법 : 수식 각 연산자에 대해 우선순위에 따라 괄호를 사용해 다시 표현. 각 연산자를 그에 대응하는 오른쪽 괄호 뒤로 이동. 괄호 제거
  
  - 변환2(스택사용): 
  
    - 중위 표기식에서 토큰 읽고 피연산자면 출력 
  
    - 토큰이 연산자(괄호포함)이면 토큰이 스택 top에 저장된 연산자보다 우선순위가 높으면 push하고 아니면(작거나 같으면) 연산자 우선순위가 토큰 우선순위보다 작을 때까지 pop한 후 push. top에 연산자 없으면 push
    - 토큰이 오른쪽 괄호면 왼쪽이 올 때 까지 pop하고 출력. 왼쪽은 pop만 하고 출력x. 더 읽을게 없다면 중지하고 없으면 다시 처음부터. 남아있는 연산자 모두 pop해서 출력
  
  icp(in-coming priority), isp(in-stack priority)

|      | ISP  | ICP  |
| ---- | ---- | ---- |
| * /  | 2    | 2    |
| + -  | 1    | 1    |
| (    | 0    | 3    |

 

### 백트래킹

- 해를 찾는 도중 막히면 되돌아가서 해를 찾는다. 최적화 문제와 결정 문제(문제의 조건을 만족하는 해가 존재하는지 여부를 yes, no로 답하는 문제)를 해결할 수 있다.
- 미로찾기 : 재귀함수, 스택(되돌아갈 곳 저장)
- 깊이우선탐색과의 차이 : 출발 경로가 해결책으로 이어지지 않을 것 같으면 더 이상 그 경로를 따라가지 않아 시도 횟수를 줄인다. 깊이 우선은 모든 경우의 수를 추적하는데 비해 백트래킹은 불필요한 경로 조기 차단.(가지치기) 따라서 경우의 수가 많을 때는 깊이우선탐색이 불가능하다. 하지만 백트래킹 역시 최악의 경우에는 지수함수 시간을 요하므로 처리 불가능.



### 퀵 정렬

- 분할 정복. 주어진 배열 두 개로 분할하고 각각 정렬한다. 합병 정렬은 그냥 두 부분으로 나누지만 퀵정렬은 기준 아이템(피벗) 중심으로 작으면 왼, 크면 오른쪽에 위치. 평균 O(n log n), 최악 O(n²)
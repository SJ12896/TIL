## 스택1

- 스택 : 물건을 쌓아 올리듯 자료를 쌓아 올린 자료구조. 저장된 자료는 선형구조(자료간 관계가 1대1, 비선형구조는 1대N으로 트리같은거). 마지막에 삽입한 자료를 가장 먼저 꺼낸다.(LIFO)
  - 자료구조 : 자료를 선형으로 저장할 저장소, 저장소 자체를 스택이라고 부르기도 한다.
  - 스택에서 마지막 삽입된 원소의 위치를 top이라고 부른다.
  - 연산 : 삽입(push), 삭제(pop -> 스택에 값이 없을 때에 대한 처리 잘해주기. 걍 return), 공백인지 확인(isEmpty), top에 있는 원소 반환(peek)
  - 응용 : 괄호검사 -> 왼, 오 괄호개수가 같아야 한다. 같은 괄호에서 왼쪽 괄호는 오른쪽보다 먼저 나와야 한다. 괄호 사이에는 포함관계만 존재한다. / pop해서 비교.
    - 문자열 괄호를 조사해서 왼쪽을 만나면 스택 삽입, 오른쪽을 만나면 top을 삭제 후 짝이 맞는지 검사
    - 스택이 비어있거나 괄호 짝이 맞지 않으면 조건 위배
    - 마지막까지 조사 후 스택에 괄호가 남아있어도 위배
  - 응용2: function call -> 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리. 가장 마지막에 호출된 함수가 가장 먼저 실행 완료. 실행이 끝나면 시스템 스택의 top이 pop. 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택 ex)전에 배웠던 재귀, 이미 많이 사용했던 list(map(int, input().split()))도 해당된다.
  - stack을 클래스로 만들고 그 안에 연산을 만들 수도 있다.
- Memoization
  - 재귀함수를 구현할 경우 중복 호출이 엄청난데 이걸 방지하기 위해 Memoization을 사용한다.
  - 이전에 계산한 값을 메모리에 저장해 전체 실행속도를 빠르게 한다.
  - 동적 계획법의 핵심이 되는 기술(DP)
  - 미리 리스트에 길이만큼 저장공간을 -1값으로 만들어뒀다가 호출할 때 값이 -1이면 값을 바꾸는 방식 or 그냥 0,1값만 만들어놓고 append하는 방식이 있다.
- DP(Dynamic Programming)
  - 그리디 알고리즘처럼 최적화 문제를 해결하는 알고리즘
  - 입력 크기 작은 부분들을 모두 해결한 후 그 해들을 이용해 보다 큰 크기의 부분 문제를 해결해 최종적으로 원래 주어진 입력의 문제 해결
  - 메모이제이션은 재귀적 구조보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다. 재귀적 구조는 내부 시스템 호출 스택을 사용해 오버헤드가 발생한다.
- **DFS(깊이우선탐색)**
  - 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다. => DFS, BFS
  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈곳이 없으면 마지막 갈림길이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색 반복해 결국 모든 정점 방문
  - 가장 마지막 갈림길로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용
  - 시작 정점 v를 결정해 방문 -> 정점 v의 인접한 정점에서 방문하지 않은 w가 있다면 v를 스택에 push, w를 방문 -> w를 v로 하여 다시 반복 -> 방문하지 않은 정점이 없다면 방향을 바꾸기 위해 pop해 가장 마지막 방문 정점을 v로 해 다시 반복 -> 스택이 공백이 될 때 까지 반복
  - 방문하지 않은 정점이 여러개면 뭘 먼저 방문할까? 알아서
  - 인접행렬 : 1과 2가 연결되어있다면 방향에 따라 단방향이면 1,2만 1로 바꾸고 2,1은 0으로 바꾼다던가 하는식으로 체크한다.
  - 인접리스트 : 연결된 정점들만 넣는다. 이것 역시 방향에 따라 단방향이면 1에만 2를 넣는다.
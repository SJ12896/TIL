### 9935_문자열 폭발

> ## 문제
>
> 상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.
>
> 폭발은 다음과 같은 과정으로 진행된다.
>
> - 문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
> - 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
> - 폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.
>
> 상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.
>
> 폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.
>
> ## 입력
>
> 첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.
>
> 둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.
>
> 두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.
>
> ## 출력
>
> 첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.

<br>

- replace밖에 못떠올렸는데 그건 너무 간단하고 문자열 백만개가 없어질때까지 순회하면서 찾다보면 안해봐도 시간초과일 것 같았다.
- 원래 문자열에서 하나씩 result에 담는데 result 길이가 bomb과 비교할 수 있게 되면 비교를 시작한다. result는 string이 거꾸로 담기기 때문에 뒤에서부터 bomb의 길이와 같은 길이만큼 추출해서 비교하고 같으면 bomb 길이만큼 pop했다. 그리고 또 string에서 새로운 문자열을 pop해서 result에 담고 비교하니까 bomb이 다시 생성되도 바로 제거할 수 있다. 문자열 끝까지 pop한 다음 다시 처음부터 하지 않아도 되니까 시간 절약.

```python
string = list(input())
bomb = list(input())
result = []

while string:
    result.append(string.pop())
    if len(result) >= len(bomb):
        temp = result[-1:-len(bomb)-1:-1]
        if temp == bomb:
            for _ in range(len(bomb)):
                result.pop()

result = ''.join(reversed(result)) if result else 'FRULA'
print(result)

```


### 11497_통나무 건너뛰기

> ## 문제
>
> 남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11497/1.png)
>
> 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다.
>
> ## 입력
>
> 입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.
>
> 이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000)
>
> ## 출력
>
> 각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.

<br>

- 내가 생각한 건 가장 짧은 통나무, 가장 긴 통나무 옆에서 중간의 통나무(짝수 일 때는 둘 중하나)가 와야한다는 아이디어였다. 하지만 이건 같은 길이 나무가 여러 개 있을 때는 틀렸다.
- 가장 긴 나무를 중심으로 양 옆으로 그 다음 길이 나무를 하나씩 배치하면 결국 다들 각자 자기와 비슷한 나무 옆에 서게 된다.
- 그런데 다른 사람들 풀이를 보니까 나처럼 양 옆에 세운다고 생각하지 않고 순서대로 인덱스 2씩 차이나는 나무와 계산했다. 내가 참 허접하게 풀었구나 하는 생각이... N에서도 어차피 인덱스-1차이나는 나무보다 -2차이나는 나무랑 더 차이가 크니까 후자만 계산해주면 된다. 

```python
import sys
input = sys.stdin.readline
T = int(input())

for tc in range(1, T+1):
    N = int(input())
    logs = list(map(int, input().split()))
    logs.sort()
    result = 0
    idx, idx2 = N-1, N-1
    for i in range(N-1, 0, -2):
        temp = logs[idx]-logs[i-1]
        temp2 = logs[idx2]-logs[i-2]
        idx, idx2 = i-1, i-2
        if temp > result:
            result = temp
        if temp2 > result:
            result = temp2
    print(result)
```


### 1937_욕심쟁이 판다

> ## 문제
>
> n*n의 크기의 대나무 숲이 있다. 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다. 그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다. 그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다. 이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다. 만약에 그런 지점이 없으면 이 판다는 불만을 가지고 단식 투쟁을 하다가 죽게 된다(-_-)
>
> 이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데, 어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 둘 다 소중한 생명이지만 판다가 최대한 오래 살 수 있는지 고민에 빠져 있다. 우리의 임무는 이 사육사를 도와주는 것이다. n*n 크기의 대나무 숲이 주어져 있을 때, 이 판다가 최대한 오래 살려면 어떤 경로를 통하여 움직여야 하는지 구하여라.
>
> ## 입력
>
> 첫째 줄에 대나무 숲의 크기 n(1 ≤ n ≤ 500)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 대나무 숲의 정보가 주어진다. 대나무 숲의 정보는 공백을 사이로 두고 각 지역의 대나무의 양이 정수 값으로 주어진다. 대나무의 양은 1,000,000보다 작거나 같은 자연수이다.
>
> ## 출력
>
> 첫째 줄에는 판다가 최대한 살 수 있는 일수(K)를 출력한다.





- 구현이야 이렇게 저렇게 짜맞춰서 할 수 있지만 좀 더 근본적으로 문제를 푸는 방법에 대해 생각해 볼 필요성을 느꼈다. 판다를 차례대로 배치해 브루트포스 방식으로 푸는 건 알겠지만 내가 새로 배치할 때마다 visited 2차원 배열을 새로 만들고 함수 안에서 길을 확인해 며칠 살았는지 visited 리스트에 기록해 시간초과가 났다. 내 풀이와 달리 max를 이용해 첫 리스트에서 최대값이 나오면 갱신하는 방법을 사용한 풀이를 참고했다.
- 내가 위와 같은 방법으로 풀면 안된다고 생각했던 이유는 판다가 계속 새로운 칸에 배치되고 새로운 방향을 통해 다시 왔던 칸으로 오는데 그 때 숫자가 계속 달라져야한다고 생각했기 때문이다. 하지만 max 함수를 사용해 해결할 수 있는 문제였다. 어차피 판다가 새로운 칸을 통해 전에 왔던 곳으로 와도 그 곳에서 이동하는 방식은 똑같다. 따라서 이전까지 버텼던 일자보다 작은 일자에 왔다면 다시 반복할 필요없으니 max에서 걸러지고 이전보다 더 버틴 다음에 왔다면 갱신될 수 있다. 
- 함수 자체에서 매개변수를 받아서 재귀로 진행되니까 stack에 쌓을 필요 없다. 
- 또 반복문 시작 전에 if visited [x[y != 0을 통해 체크해서 온 적 없는 칸 아닌 이상 전의 최고값을 바로 반환하고 아니면 일단 1로 초기화한다.

```python
import sys
n = int(sys.stdin.readline())

bamboo = []
for i in range(n):
    bamboo.append(list(map(int, sys.stdin.readline().split())))

dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]


def dfs(x, y):
    if visited[x][y] != 0:
        return visited[x][y]

    visited[x][y] = 1
    
    for direction in range(4):
        nx = x + dx[direction]
        ny = y + dy[direction]
        if 0 <= nx < n and 0 <= ny < n and bamboo[nx][ny] > bamboo[x][y]:
            # 여기서 새로 이동한 칸을 1증가 시키는게 아니라 처음 들어왔던 x,y의 값을 늘려간다. 왜 그렇게 했을까 생각해봤는데 nx ny로 하면 마지막에 return을 할 수 없다. 나라면 생각의 틀에 갇혀서 무조건 이동한 쪽의 날짜를 증가시켰을 것 같은데 이런 발상의 전환이 필요하다. 
            visited[x][y] = max(dfs(nx, ny)+1, visited[x][y])

    return visited[x][y]


result = 0
visited = [[0] * n for _ in range(n)]
for i in range(n):
    for j in range(n):
        result = max(dfs(i, j), result)

print(result)
```


### 1149_RGB 거리

> ## 문제
>
> RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
>
> 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
>
> - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
> - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
> - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
>
> ## 입력
>
> 첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.
>
> ## 출력
>
> 첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.



- 음... 다이나믹 프로그래밍에서 식을 세워야하는데 그걸 못했다. 뭔가 2차원 배열을 사용해야 할 것 같은데 그걸 어떤 식으로 진행해 나가야 될 지 감을 못잡았다. 
- 나는 계속 빨초, 빨파 중 작은 값을 택했는데 갑자기 3번에서 값이 엄청 커지면 상관없어지는데 어떻게 해야할까 고민했는데 2차원 배열안에서 expense[i]에 [빨간색, 초록색,파란색]으로 칠했을 때 값을 기록하는데 마찬가지로 expense[i-1]에도 [빨간색, 초록색,파란색] 값이 있다. 
- 2번 집을 빨강으로 칠했을 때 : min(초록+빨강, 파랑+빨강) => 초록+빨강
- 2번 집을 초록으로 칠했을 때 : min(빨강+초록, 파랑+초록) => 빨강+초록
- 2번 집을 파랑으로 칠했을 때 : min(빨강+파랑, 초록+파랑) => 빨강+파랑
- 3번 집을 빨강으로 칠했을 때 : min(빨강+초록+빨강, 빨강+파랑+빨강) 
- 3번 집을 초록으로 칠했을 때 : min(초록+빨강+초록, 빨강+파랑+초록)
- 3번 집을 파랑으로 칠했을 때 : min(초록+빨강+파랑, 빨강+초록+파랑)
- 만약에 3번에서 어떤 두 값이 극단적으로 크고 다른 한 값이 극단적으로 작다 해도 매 집마다 빨, 초, 파를 전부 검사하기 때문에 상관없다. 값 기록도 빨강으로 끝나는 경우, 초록으로 끝나는 경우, 파랑으로 끝나는 경우 전부 있다. 매 집마다 한 가지 경우를 선택해서 그 값으로 진행해나가는게 아니다.
- 뭔가 알겠는데 맘으로 잘 안와닿는 느낌이다. 분명 전에 이런 비슷한 거 풀었는데 또 접근 방법도 제대로 몰랐던 걸 보면 역시 dp가 많이 부족하다.

```python
N = int(input())
expense = []
for i in range(N):
    # 1번 집부터 빨, 초, 파로 칠하는 비용
    expense.append(list(map(int, input().split())))

for i in range(1, N):
    expense[i][0] = min(expense[i-1][1], expense[i-1][2]) + expense[i][0]
    expense[i][1] = min(expense[i - 1][0], expense[i - 1][2]) + expense[i][1]
    expense[i][2] = min(expense[i - 1][1], expense[i - 1][0]) + expense[i][2]

print(min(expense[N-1]))
```


### 1913_달팽이



> ## 문제
>
> 홀수인 자연수 N(3≤N≤999)이 주어지면, 다음과 같이 1부터 N2까지의 자연수를 달팽이 모양으로 N*N의 표에 늘어놓을 수 있다.
>
> | 9    | 2    | 3    |
> | ---- | ---- | ---- |
> | 8    | 1    | 4    |
> | 7    | 6    | 5    |
>
> | 25   | 10   | 11   | 12   | 13   |
> | ---- | ---- | ---- | ---- | ---- |
> | 24   | 9    | 2    | 3    | 14   |
> | 23   | 8    | 1    | 4    | 15   |
> | 22   | 7    | 6    | 5    | 16   |
> | 21   | 20   | 19   | 18   | 17   |
>
> N이 주어졌을 때, 이러한 표를 출력하는 프로그램을 작성하시오. 또한 N2 이하의 자연수가 하나 주어졌을 때, 그 좌표도 함께 출력하시오. 예를 들어 N=5인 경우 6의 좌표는 (4,3)이다.
>
> ## 입력
>
> 첫째 줄에 홀수인 자연수 N이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다.
>
> ## 출력
>
> N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력한다.



- 2차원 배열에서 이동하는 문제 너무 어렵다. 풀긴했는데 이렇게 푸는게 맞는건가? 하는 의문이 든다.

```python
N = int(input())

num = int(input())

# 위, 오른쪽, 아래, 왼쪽으로 이동하기 위해 만들었다.
dx = [-1,0,1,0]
dy = [0,1,0,-1]
# dir 값에 따라 이동 방향이 바뀐다.
dir = 0

graph = [[0] * N for i in range(N)]
# 시작되는 곳의 값은 미리 넣어뒀다.
graph[len(graph)//2][len(graph)//2] = 1

# 시작하는 곳의 행, 열 위치도 미리 정해둔다.
x, y = len(graph)//2, len(graph)//2

# i는 행과 열에 들어갈 값이다. 이 수는 N*N까지 증가한다.
i = 2
# k는 한 방향으로 이동하는 횟수다. 2번을 기준으로 증가하는데 1번 가고 방향 바뀌고 1번 가고 방향 바뀌고 2번 가고 방향바뀌고 2번 가고 방향 바뀌고 3번 가고 방향바뀌고 3번가고 방향 바뀌고 4번 가고... 이렇게 전개된다. 그런데 문제점은 마지막에 N번 이동인데 그래프가 끝나기 때문에 N-1번만 가야한다. 그걸 따로 설정해주기 어려워 그래프를 끝내고 마지막 열만 다른 반복문에서 채워주었다.
k = 1

while True:

    for l in range(2):

        for j in range(k):
            x += dx[dir]
            y += dy[dir]
            graph[x][y] = i
            i += 1

        dir += 1
        if dir == 4:
            dir = 0

        if i == N*N+1:
            break

    k += 1
    if k == N:
        break
        
# 마지막 열을 채우는 반복문이다.
for i in range(N):
    graph[i][0] = N*N-i
    print(*graph[i])

for i in range(N):
    for j in range(N):
        if num == graph[i][j]:
            print(i+1, j+1)
            break
```


### 15900_나무 탈출

> ## 문제
>
> 평소에 사이가 좋지 않던 성원이와 형석이가 드디어 제대로 한 판 붙으려고 한다. 성원이와 형석이 둘과 모두 똑같이 친한 인섭이가 대결 종목을 정해 가져왔다. 바로 '나무 탈출' 이라는 보드게임이다.
>
> '나무 탈출' 은 N개의 정점이 있는 트리 모양으로 생긴 게임판과 몇 개의 게임말로 이루어진다. 트리의 각 정점에는 1번부터 N번까지 번호가 붙어있다. 1번 정점은 '루트 노드' 라고 불리며, 이 루트 노드를 중심으로 정점 간에 부모-자식 관계가 만들어진다. 자식이 없는 노드는 '리프 노드' 라고 불린다.
>
> 이 게임은 두 사람이 번갈아 가면서 게임판에 놓여있는 게임말을 움직이는 게임이다. 처음에는 트리의 모든 리프 노드에 게임말이 하나씩 놓여있는 채로 시작한다. 어떤 사람의 차례가 오면, 그 사람은 현재 존재하는 게임말 중 아무거나 하나를 골라 그 말이 놓여있던 노드의 부모 노드로 옮긴다. 이 과정에서 한 노드에 여러 개의 게임말이 놓이게 될 수도 있다. 이렇게 옮긴 후에 만약 그 게임말이 루트 노드에 도착했다면 그 게임말을 즉시 제거한다. 모든 과정을 마치면 다음 사람에게 차례를 넘긴다. 이런 식으로 계속 진행하다가 게임말이 게임판에 존재하지 않아 고를 수 없는 사람이 지게 된다.
>
> 성원이를 얕본 형석이는 쿨하게 이 게임의 선을 성원이에게 줘버렸다. 따라서 성원이가 먼저 시작하고 형석이가 나중에 시작한다. 그동안 형석이와 대결을 하면 매번 지기만 했던 성원이는 마음속에 분노가 가득 쌓였다. 이번 대결에서는 반드시 이겨서 형석이의 코를 꺾어주고 싶다. 그래서 게임을 시작하기 전에 게임판의 모양만 보고 이 게임을 이길 수 있을지 미리 알아보고 싶어졌다. 성원이가 이 게임을 이길 수 있을지 없을지를 알려주는 프로그램을 만들어 성원이를 도와주자.
>  
>
> ## 입력
>
> 첫째 줄에 트리의 정점 개수 N(2 ≤ N ≤ 500,000)이 주어진다.
>
> 둘째 줄부터 N-1줄에 걸쳐 트리의 간선 정보가 주어진다. 줄마다 두개의 자연수 a, b(1 ≤ a, b ≤ N, a ≠ b)가 주어지는데, 이는 a와 b 사이에 간선이 존재한다는 뜻이다.
>
> ## 출력
>
> 성원이가 최선을 다했을 때 이 게임을 이길 수 있으면 `Yes`, 아니면 `No`를 출력한다.

<br>

- python3 시간초과, pypy3로 통과
- python3으로 통과할 수 있을까 궁금해서 검색해봤는데 재귀 깊이를 늘려서 dfs로 풀면 되는 거 같다. 이 때 stack을 사용하지 않아서 append popleft하는 과정없이 한다. 
- dfs가 시간이 더 빠를 수도 있구나... 
- bfs문제를 그렇게 많이 풀었는데 아직도 헷갈리는 게 있다는 점이 놀랍다. 지금 너무 졸려서 그랬던거라고 믿고싶다. 어차피 bfs로 진행하면서 visited 체크하면 알아서 아래로만 내려갈테고 부모가 여러개여도 상관없이 단말노드 개수가 중요하니까 그런점도 고려할 필요없다.

```python
import sys
from collections import deque
input = sys.stdin.readline


def bfs():
    global result
    while q:
        x, cnt = q.popleft()
        check = True
        for i in tree[x]:
            if not visited[i]:
                visited[i] = 1
                q.append([i, cnt+1])
                check = False
        if check:
            result += cnt


N = int(input())
tree = [[] for _ in range(N+1)]
for i in range(N-1):
    a, b = map(int, input().split())
    tree[a].append(b)
    tree[b].append(a)

q = deque([])
result = 0
visited = [0] * (N + 1)
visited[1] = 1

for i in tree[1]:
    q.append([i, 1])
    visited[i] = 1
bfs()
print('Yes' if result % 2 else 'No')
```


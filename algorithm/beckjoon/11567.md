### 11567_선진이의 겨울 왕국

> ## 문제
>
> 겨울 왕국에 나오는 올라프의 유일한 후손인 선진이는 현재 엘사가 얼려놓은 빙판길 위에 서 있다.
>
> 빙판길은 n×m의 크기를 갖는 직사각형 격자모양이고, 빙판길의 각 칸은 손상되거나 손상되지 않은 상태이다. 손상된 칸은 영대문자 `X`로, 손상되지 않은 칸은 `.` 으로 주어진다.
>
> 빙판길은 크기가 n×m인 직사각형 격자모양이고, 빙판길 각 칸의 얼음은 이미 손상되어 있거나, 손상되지 않은 상태이다.
>
> 그리고 직사각형의 행을 위에서부터 아래로 1부터 n까지, 열을 왼쪽에서부터 차례대로 1부터 m이라 가정한다.
>
> 만약 선진이가 빙판길에서 손상된 칸으로 이동하면 빙판길 아래로 추락하여 동사하기 때문에, 각 칸에 상하좌우로 인접하면서 손상되지 않은 얼음이 있는 칸으로 이동해야만 한다.
>
> 그리고 빙판의 상태가 약하기 때문에, 현재 위치에서 다른 칸으로 이동을 하면 이동하기 전 위치의 얼음은 손상된 상태로 바뀌게 된다.
>
> | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11567/1.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11567/2.png) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | (a)                                                          | (b)                                                          |
>
> 예를 들어서 그림(a)와 같이 (1, 1)에 서 있는 선진이가 그림(b)와 같이 오른쪽으로 한 칸 이동하게 되면, 선진이의 위치는 (1, 2)가 되고 (1, 1)의 얼음은 손상되어 더 이상 지나갈 수 없게 된다. 
>
> 그리고 (r2, c2) 에 위치한 올라프가 만든 탈출구는 빙판길 밑에 있기 때문에 (r2, c2)의 얼음을 손상 시키고, 손상된 얼음을 다시 밟아 추락해야지 탈출구를 이용할 수 있게 된다.(이미 탈출구 위의 얼음이 손상되어 있을 수도 있다.)
>
> 선진이가 있는 빙판길의 상태가 주어지고, 시작 위치 (r1, c1)와 탈출구가 있는 지점 (r2, c2) 가 주어져 있을 때, 선진이가 탈출구를 이용해 탈출이 가능한지 불가능한지 판별하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫 번째 줄은  두 개의 정수 n, m (1 ≤ n, m ≤ 500)이 주어진다. n은 격자에서 행의 개수를 의미하고, m은 열의 개수를 의미한다.
>
> 다음 n개의 줄에는 각각 m개의 문자로 이루어진 빙판길의 초기 상태가 주어진다. (손상된 얼음이면 '`X`'로 표시되고, 손상되지 않은 얼음은 '`.`' 으로 표시된다.)
>
> 다음 줄은 두개의 정수 r1과 c1 (1 ≤ r1 ≤ n, 1 ≤ c1 ≤ m)이 주어진다. 이는 선진이의 초기위치를 나타내고, 초기위치의 빙판길의 상태는 ‘`X`’로 주어진다.
>
> 다음 줄은 두개의 정수 r2과 c2 (1 ≤ r2 ≤ n, 1 ≤ c2 ≤ m)가 주어진다. 이는 올라프가 만들어 놓은 탈출구의 위치를 나타내며, 초기 위치와 일치할 수도 있다.
>
> ## 출력
>
> 선진이가 탈출 할 수 있다면, YES를 출력하고, 없다면 NO를 출력한다.

<br>

- Gold2 문제는 잘 안푸는데 내 이름이라 꼭 풀고싶어서 풀었다.
- 처음엔 더 꼬아서 푸는 방식을 생각했는데 그럴 필요 없었다. 원래는 내가 지나온 route를 기억해서 그 안에 목적지의 4방향 중 .으로 표시된 부분이 전부 들어가 있다면 NO가 되도록 생각했다.
- 그런데 굳이 그럴 필요 없이 일단 한 번 스쳐지나간 다음에 다시 방문할 수 있다는게 증명되면 YES가 되는 문제였다. 정확히 알고리즘을 알고 있지 않으니까 꼬아서 생각하는 방식으로만 풀려고 하는 느낌이다. 쉽게 풀 수 있는데...
- 결국 목적지에 도달하는 방법이 2개 이상이면 된다는 말!

```python
import sys
from collections import deque
input = sys.stdin.readline
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def bfs():
    global result
    while q:
        x, y = q.popleft()
        for d in range(4):
            nx = x+dx[d]
            ny = y+dy[d]
            if 0 <= nx < n and 0 <= ny < m:
                if ice[nx][ny] == '.':
                    q.append([nx, ny])
                    ice[nx][ny] = 'X'
                elif ice[nx][ny] == 'X' and nx == r2 and ny == c2:
                    result = 'YES'
                    return


n, m = map(int, input().split())
ice = []
for i in range(n):
    ice.append(list(input()))
r1, c1 = map(int, input().split())
r2, c2 = map(int, input().split())
r1 -= 1
c1 -= 1
r2 -= 1
c2 -= 1
q = deque([[r1, c1]])
result = 'NO'
bfs()
print(result)
```


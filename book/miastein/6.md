## 6. 파이썬 고급 주제

<br>

### 6-1. 멀티 프로세스와 멀티 스레드

- 운영체제에서 실행되는 각 프로그램은 각각이 별도의 프로세스다. 각 프로세스는 하나 이상의 스레드가 있다. 한 프로세스에 여러 개의 스레드가 있다면 여러 작업을 마치 동시에 수행하는 것처럼 보인다. 멀티 프로세스, 멀티 스레드 두 방법을 사용하면 프로그램의 작업 부하를 분산시킬 수 있다.
- 멀티 프로세스 : 별도 메모리 영역을 가지며 프로세스간 통신(inter-process communication, IPC)으로만 통신할 수 있다. 프로세서는 각 스레드에 대해 별도의 레지스터 집합을 불러오거나 저장하는데, 프로세스 간 데이터 공유와 통신용으로는 비효율적이다. 파이썬은 멀티 프로세스 방식에 subprocess 모듈을 사용한다.

---

- [프로세서(processor)](https://ko.wikipedia.org/wiki/%EC%A4%91%EC%95%99_%EC%B2%98%EB%A6%AC_%EC%9E%A5%EC%B9%98) : 중앙 처리 장치. CPU. 컴퓨터 시스템 통제하고 프로그램 연산 실행하고 처리하는 컴퓨터 제어 장치
- [프로세서 레지스터(processor register)](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0) : 프로세서 내에서 자료를 보관하는 아주 빠른 기억 장소. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용. 대부분 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리하고 다시 레지스터에서 메인 메모리로 저장한다. 메모리 계층 최상위에 위치하며 가장 빠른 속도로 접근 가능하다. 

---

- 멀티 스레드 : 단일 프로세스 내의 멀티 스레드는 동일한 메모리에 접근. 스레드는 데이터 공유를 통해 간단하게 통신하는데, threading 모듈의 처리를 통해 한 번에 한 스레드만 메모리 영역 접근 가능. 각 프로세스가 독립적인 스택stack, 힙heap, 코드code, 데이터data 영역을 가지는 반면, 한 프로세스에 속한 스레드는 스택 영역을 제외한 메모리 영역을 공유한다. 
  - 멀티 스레드에서 한 스레드는 인터프리터 락(interpreter lock)을 획득해야만 실행될 수 있다. 파이썬은 이런 인터프리터 락이 하나만 존재하며 GIL(global interpreter lock)이라고 한다. GIL을 획득한 스레드가 어떤 자원을 사용한다면 다른 스레드들은 이 자원에 접근하지 못하고 대기 상태에 놓인다.
- 동시성concurrency : 논리적으로 여러 작업이 동시에 실행되는 것처럼 보이는 것. 한 작업의 I/O 연산이 완료되기를 기다리는 동안 다른 작업을 수행해 유휴 시간을 활용하는 것이 동시성 => I/O 작업이 많다면 병렬성보다 동시성을 사용하는 게 유리할 수 있다.
- 병렬성parallelism : 물리적으로 여러 작업이 동시에 처리되는 것. 데이터 병렬성, 작업 정렬성이 있다. 데이터 병렬성은 같은 작업을 병렬 처리. (하나의 큰 작업을 쪼개서) 작업 병렬성은 서로 다른 작업을 병렬 처리. 웹 서버에서 다수의 독립적인 요청을 병렬로 개별적으로 처리할 수 있다.

<br>

#### 6-1-1. subprocess 모듈

- 부모-자식 프로세스 쌍 생성에 사용. 부모 프로세스는 사용자에 의해 실행. 부모 프로세스는 차례로 다른 일을 처리하는 자식 프로세스의 인스턴스 실행. 자식 프로세스를 사용해 멀티 코어의 이점을 취하고 동시성 문제를 운영 체제가 알아서 처리하도록 한다. 

(솔직히 subprocess 관련 내용은 이해할 수 없었다. 추후 다시 공부하자.)

<br>

#### 6-1-2. threading 모듈

- 스레드 여러개일 때 : 스레드 간 데이터 공유 복잡성 증가 / 락(여러 스레드 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 매커니즘), 데드락 회피에 주의 기울여야 함
- 파이썬 프로그램에 하나의 메인 스레드만 존재. 멀티 스레드를 사용하기 위해서는 threading 모듈 사용.
- 내부적 락 관리는 queue 사용. -> 자원 접근 직렬화 -> 한 번에 하나의 스레드만 데이터 접근할 수 있다.(FIFO)
- worker thread가 작업 완료했는데 프로그램이 종료되지 않고 계속 실행되면 문제가 될 수 있음 -> 스레드를 데몬daemon으로 변환하면 데몬 스래드가 실행되지 않는 즉시 프로그램 종료

---

- [데몬](https://ko.wikipedia.org/wiki/%EB%8D%B0%EB%AA%AC_(%EC%BB%B4%ED%93%A8%ED%8C%85)) : 멀티태스킹 운영 체제에서 사용자가 직접 관리하지 않고 백그라운드에서 여러 작업을 하는 프로그램.
- 이해가 안가는 부분이 많아서 [파이썬 스레드](https://wikidocs.net/82581)를 봤다.

---

<br>

#### 6-1-3. 뮤텍스와 세마포어

- 뮤텍스mutex : 공유 리소스에 한 번에 하나의 스레드만 접근하도록 상호 배제mutual exclusion 동시성 제어 정책을 강제하기 위해 설계
  - ex) 한 스레드가 배열 수정하는 중 프로세서가 다른 스레드로 전환한다면 뮤텍스를 사용하지 않으면 두 스레드가 동시에 배열을 수정하는 일이 벌어진다.
  - 뮤텍스는 1부터 시작하는 정수. 스레드는 배열을 변경할 때 뮤텍스를 잠근다. 스레드는 뮤텍스가 양수가 될 때까지 대기한 다음 숫자 1 감소(락) -> 수정 마치면 잠금 해제되며 숫자 1 증가(언락)
- 세마포어semaphore : 뮤텍스보다 일반적으로 사용. 1보다 큰 수로 시작할 수 있음. 세마포어 값 = 한 번에 자원에 접근할 수 있는 스레드 수
  - 뮤텍스의 락, 언락 작업과 유사한 대기wait 및 신호signal 작업 지원. 

<br>

#### 6-1-4. 데드락과 스핀락

- 데드락(교착 상태, deadlock) : 두 개 이상 프로세스나 스레드가 서로 상대방 작업이 끝나기만 기다리고 있어 결과적으로 아무것도 완료X
  - 프로그램에 락 할당 -> 순서대로 획득하면 일반적으로는 막을 수 있다.
- 다음 네 가지 조건 충족 시 데드락 발생. 하나라도 막는다면 해결
  - 상호 배제mutual exclusion : 자원은 한 번에 한 프로세스(혹은 스레드)만 사용가능
  - 점유와 대기hold and wait : 한 프로세스가 자원 가진 상태에서 다른 프로세스가 쓰는 자원 반납 기다림
  - 비선점 no preemption : 다른 프로세스가 이미 점유한 자원 강제로 뺏지 못하게 함
  - 순환 대기circular wait : 프로세스 A, B, C가 있을 떄 A는 B가 점유한 자원을, B는 C가 점유한 자원을, C는 A가 점유한 자원을 대기하는 상태
- 스핀락spinlock : 전체 시스템이 단일 애플리케이션 전용이고 코어당 하나의 스레드만 사용하는 고성능 컴퓨팅 상황에 유용한 바쁜 대기busy wait의 한 형태다. 임계 구역 진입이 불가능할 때, 가능할 때 까지 반복문을 돌며 재시도하는 방식

---

- [바쁜 대기](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%81%9C_%EB%8C%80%EA%B8%B0) : 어떤 특정 공유자원에 대해 두 개이상 프로세스나 스레드가 그 이용 권한 획득하기 위한 동기화 상황에서 그 권한 획득을 위한 과정에서 일어나는 현상. 스핀락과 동일하게 생각하지만 엄밀히 하면 스핀락이 바쁜 대기 개념을 이용한 것. 
  - 공유 자원 권한 획득 아주 빠른 시간 내 이루어질 수 있다는 확신이 있는 상황에서 뮤텍스나 세마포어 같은 동기화 객체 이용은 오버헤드가 큰 상황에서 간단히 쓸 수 있다.

---

<br>

### 6-2. 좋은 습관

#### 6-2-2. 디버깅

- 디버거 pdb 사용
- 스크립트 파일을 대화식 인터프리터로 살펴보고 싶으면 -i 뒤에 파일명을 적거나 -m pdb 뒤에 파일명 적어서 실행. 
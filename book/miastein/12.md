## CHAPTER 12. 그래프 기초

### 12-1. 용어

- 그래프 : 여러 노드(또는 정점vertex)들이 간선(또는 아크arc)으로 연결된 추상 네트워크. 즉 노드와 간선의 집합으로 정의되며 수식으로 쓰면 G = (V, E)라고 한다. V는 노드 집합, 간선 집합 E는 노드 쌍들의 집합이다.

#### 12-1-1. 그래프 방향

- 유향directed, 무향undirected
- 무향 : 간선으로 연결된 노드는 서로 인접adjacent해 있고 이웃neighbor이라고 한다.
- 유향 : 순서가 존재하므로 말단leaf 노드가 존재한다. 

#### 12-1-2. 부분 그래프

- 그래프 G에서 집합 V와 E로 구성된 그래프의 일부다. 
- G3 그래프가 G2 그래프에 속해있으면 유도 부분 그래프induced subgraph라고 한다.
- 신장 부분 그래프spanning subgraph는 원본 그래프의 모든 노드를 포함하는 부분 그래프

#### 12-1-3. 완전 그래프

- 그래프 모든 노드가 서로 인접한 그래프를 말한다.

#### 12-1-4. 차수

- 한 노드에 이어져 있는 간선의 수를 차수degree라고 한다. 차수가 0인 노드는 고립isolated되었다고 한다. 유향 그래프는 입력 차수in-degree와 출력 차수out-degree로 나눌 수 있다.

#### 12-1-5. 경로, 보행, 순환, 길이

- 경로path : 간선이 어느 노드도 다시 방문하지 않고 노드가 일렬로 연결된 부분 그래프. 유향 그래프에서 경로는 간선의 방향을 따른다.
- 보행walk : 노드와 간선을 번갈아 가며 반복적으로 방문하는 노드와 간선. 경로는 노드와 간선이 모두 중복되지 않는 보행
- 순환cycle : 경로와 같지만 마지막에 연결된 간선 노드가 첫 번째 노드에 연결
- 경로 길이 : 경로 또는 보행의 길이는 간선의 수와 동일하다. (약간 헷갈렸는데 전체 간선이 아니라 경로 있는 간선 수를 말하는 듯 하다.)

#### 12-1-6. 가중 그래프

- 간선에 가중치weight가 있는 그래프다. 경로 또는 순환의 가중치는 해당 간선들의 가중치의 총합이다. 가중 그래프가 아닌 경우 경로와 순환의 가중치가 간선 수와 같다.
- 순회traversal : 그래프에 연결된 모든 요소를 탐색하는 일. 중요한 것은 아직 방문하지 않은 노드의 순회 순서
- 연결 : 모든 노드에서 다른 모든 노드로 가는 경로가 존재할 때
- 연결요소connected component : 모든 노드가 연결된 최대 부분 그래프. 깊이 우선 탐색과 너비 우선 탐색 같은 순회 알고리즘을 사용해 찾을 수 있다.
- 트리와 포레스트 ; 포레스트는 순환이 없는 그래프다. 트리는 비순환적이고 연결되어 있는 유향 그래프다. 포레스트는 하나 이상의 트리로 구성되어 있다. 즉, 서로 독립적인 트리의 모임. 트리에서 두 노드는 정확히 하나의 경로로 연결된다. 트리에 새로운 간선을 하나 추가하면 순환이 생기고, 어떤 간선을 제거하면 연결되지 않은 요소가 생성된다.

<br/>

### 12-2. 이웃 함수

- 그래프의 이웃 함수 N(V)는 모든 이웃 V의 컨테이너(또는 반복 가능한 객체)다. 그래프 이웃 함수로 가장 잘 알려진 자료구조는 인접 리스트와 인접 행렬이다.

#### 12-2-1. 인접 리스트

- 인접 리스트는 셋이나 리스트, 딕셔너리로 구현할 수 있다. 셋의 평균 시간 복잡도는 O(1)이고 최악은 O(n), 리스트는 O(n)이다.
- 이웃 노드를 반복해서 접근하는 경우 리스트, 그래프가 촘촘한(간선이 많은) 경우 셋을 사용
- 리스트 중간에서 객체를 삭제하는 시간복잡도는 O(n)이지만 끝에서 삭제하면 O(1)이다. 이웃 노드 순서가 중요하지 않다면 `삭제하려는 임의의 이웃을 마지막 항목으로 위치를 바꾸고swap `그 다음 pop()해준다. 
- 딕셔너리 : 노드가 키가 되고 각 노드를 간선 가중치 값으로 연결할 수 있다.

---

#### 의문점

[파이썬 시간 복잡도](https://wiki.python.org/moin/TimeComplexity)

- 리스트와 셋에서 x in s 연산의 평균 시간복잡도 차이가 나는 이유가 궁금했다. 바로 해시 테이블 때문이었는데 한 블로그에서 잘 설명된 글을 발견했다. 
- [Python - set()에서의 원소 검색은 어떻게 O(1)이 될까?](https://rexiann.github.io/2020/11/28/set-in-python.html)

- 해시 테이블로 키에 값을 저장한다는걸 보면 dictionary 같은 형태라고 생각하는데 set은 key값이 없어서 어떻게 해시 테이블이라는지 이해가 잘 안갔다. 공식문서에서도 가변인 set은 해시 값이 없고 frozenset은 불변이고 해시 가능하다고 한다. 위 블로그에서 보면 hash function을 통해 변경이 된 key는 값과 함께 저장소에 저장되는데 set은 좀 다른 작용을 하는 것 같다. 약간 애매한데 그럭저럭 이해는 간다.

---

<br/>

### 12-3. 트리와의 연결점

- 그래프에서 어떤 노드는 다른 노드에 의해 다중 참조될 수 있다. 하지만 트리에서는 각 노드는 최대 하나의 부모 노드(상위 노드)에 의해서만 참조된다. 루트 노드는 부모가 없는 노드를 말한다. 부모 노드를 참조하는 노드는 자식 노드다. 

### 12-3-1. 트리 구현하기

- 가장 간단한 방법은 중첩 리스트를 사용하는 것이지만 두 개 이상의 가지가 추가되면 매우 불편하다. 트리를 클래스로 정의하는 것이 좋다. 
- 뭔가 간단해보이면서 복잡해 보이는 게 좋은 것 같기도 하고 아닌 것 같기도 하다.

```python
class SimpleTree(object):
    def __init__(self, value=None, children=None):
        self.value = value
        self.children = children
        if self.children is None:
            self.children = []

    def __repr__(self, level=0):
        ret = "\t"*level + repr(self.value) + "\n"
        for child in self.children:
            ret += child.__repr__(level+1)
        return ret


def main():
    st = SimpleTree('a', [
        SimpleTree('b', [
            SimpleTree('d'),
            SimpleTree('e')
        ]),
        SimpleTree('c', [
            SimpleTree('h'),
            SimpleTree('g')
        ])
    ])
    print(st)


if __name__ == '__main__':
    main()
```

```bash
'a'
	'b'
		'd'
		'e'
	'c'
		'h'
		'g'

```

<br/>

<br/>

## 13. 이진 트리

- 이진 트리binary tree : 노드가 최대 두 개의 자식 노드(왼쪽, 오른쪽)을 갖는 자료구조다. 자식 노드는 부모 노드에 대한 참조를 포함할 수 있다.

### 13-1. 용어

- 노드 차수degree : 자식 수
- 노드 깊이depth : 루트에서 어떤 노드로 가는 경로 길이
- 노드 레벨level : 루트에서 어떤 노드로 가는 경로 길이 + 1
- 크기size : 모든 노드 수
- 높이height : 한 노드와 단말 노드 사이 최대 경로 길이

- 포화 이진 트리perfect binary tree : 모든 내부 노드가 두 개의 자식 노드를 가지며 모든 말만 노드가 같은 깊이 또는 레벨을 가진다.
- 완전 이진 트리complete binary tree : 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨이 모든 말단 노드는 왼쪽에 있다. 

### 13-2. 이진 탐색 트리

- 이진 탐색 트리binary search tree(BST)는 노드를 정렬된 순서로 유지하는 자료구조다. 각 노드에 값과 두 자식 노드에 대한 포인터가 있다. 선택적으로 부모 노드 포인터를 저장할 수도 있다. 각 노드 값은 왼쪽 하위 트리 모든 항목보다 크고 오른쪽 하위 트리 모든 항목보다 작다.  왼쪽과 오른쪽 하위 트리 모두 이진 탐색 트리여야 한다.
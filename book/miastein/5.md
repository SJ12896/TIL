## 5. 객체지향 설계

- 우리가 기대하는 속성만 가진 객체를 만들어야 한다. 데이터를 패키지화하고 메서드를 제한해야 한다. -> 객체지향 프로그래밍

### 5-1. 클래스와 객체

- 클래스 : 사전에 정의된 특별한 데이터와 메서드의 집합. 클래스에 선언된 모양 그대로 생성된 실체를 객체object라고 한다. 객체가 소프트웨어에 실체화될 때(메모리에 할당되어 사용), 이 실체를 인스턴스instance라고 한다. 

#### 5-1-1. 클래스 인스턴스 생성

- 함수 표기법을 사용해 초기 상태의 객체 생성. 어떤 특징을 가진 빈 객체를 만드는 것
- (여러 범위의) 여러 이름을 같은 객체에 바인딩binding(또는 에일리어싱aliasing)할 수 있다.

---

- [파이썬 공식문서](https://docs.python.org/ko/3/tutorial/classes.html)
- 객체는 개체성을 가지며 여러 개의 이름이 여러 스코프에서 같은 객체에 연결될 수 있다. 다른 언어들에서는 에일리어싱이라고 알려져있다. 불변형인 숫자, 문자열, 튜플을 다룰 때는 상관없지만 포인터처럼 동작하기 때문에  리스트, 딕셔너리같은 가변형 객체에선 신경써야 한다. 

---

- Hello클래스가 있을 때 Hello()를 호출하면 객체를 생성하는데 이 때 Hello()를 생성자constructor라고 한다. 생성자를 호출하면 `Hello.__new__()`라는 특수 메서드가 호출되어 객체가 할당되고 그 다음 `Hello.__init__()` 메서드가 객체를 초기화한다.

---

참고?

- [__init__ as a constructor?](https://stackoverflow.com/questions/6578487/init-as-a-constructor)
- `Foo()` : **constructor**
- `Foo.__init__()` : **initializer** / 
- `Foo.__new__()` : **allocator**
- [파이썬 공식문서](https://docs.python.org/ko/3.8/reference/datamodel.html?highlight=constructor#object.__init__)
- init : 인스턴스 생성 후(new를 통해) 호출자에게 반환되기 전 호출된다. 기본 클래스에 init 메서드가 있으면 파생 클래스의 init에서 기본 클래스 부분을 적절하게 초기화하기 위해 호출해야 한다. 

---

- 속성 : 객체에는 데이터와 메서드로 이루어지는 클래스 속성attribute이 있다. 메서드 속성은 함수인데 그 첫번째 인수는 호출된 인스턴스 자신이다.(self)
- 속성은 .뒤에 나오는 모든 이름이다. 모듈 내 모든 이름의 참조는 속성 참조다. 모듈명.함수명과 같은 표현식에서 모듈명은 모듈 객체, 함수명은 객체의 속성 중 하나다. 속성은 읽기 전용이거나 쓰기 가능할 수도 있다. 쓰기 가능 속성은 del문으로 삭제할 수 있다.

- 네임스페이스namespace : 이름을 객체로 매핑. 대부분 네임스페이스는 파이썬 딕셔너리로 구현. 내장된 이름 셋, 모듈 전역 이름, 함수 지역 이름 등이 있다. 

- 스코프scope : 네임스페이스에 직접 접근할 수 있는 파이썬 프로그램의 텍스트 영역text region(원래 정의된 곳 정도의 의미). 스코프는 정적으로 결정되지만 동적으로 사용된다. 한 모듈에 정의된 함수의 전역 스코프는 해당 모듈의 네임스페이스다. 클래스에 정의가 실행되면, 새로운 네임스페이스가 만들어지고 지역 스코프로 사용된다.

<br/>

### 5-2. 객체지향 프로그래밍의 원리

#### 5-2-1. 특수화

- 특수화specializtion는 슈퍼super 클래스(부모parent, 베이스base 클래스)의 모든 속성을 상속inheritance하여 새 클래스를 만드는 절차다. 모든 메서드는 서브sub 클래스(자식child 클래스)에서 재정의override(재구현re-implemented)될 수 있다. 
- 상속은 is-a 관계다. 모든 학생은 사람이지만 모든 사람이 학생은 아니다.
- has-a 관계: 지우개 연필에서 연필은 지우개 클래스를 소유할 수 있다.
- 구글 스타일 가이드는 한 클래스가 다른 클래스를 상속받지 않으면 최상위 클래스인 object를 명시적으로 표기하는 걸 권장

#### 5-2-2. 다형성

- 다형성polymorphism(또는 동적 메서드 바인딩)은 메서드가 서브 클래스 내에서 재정의될 수 있다는 원리다. 슈퍼 클래스 메서드를 호출해야 하면 super() 메서드 사용.
- 파이썬에서 사용자 정의 클래스의 모든 객체는 기본적으로 해시 가능hashable하다. 객체가 `해시가능하다`는 것은 hash()속성을 호출할 수 있다는 뜻이며 `불변 객체`임을 의미한다. 

---

- [파이썬 공식문서 - hashable(해시 가능)](https://docs.python.org/ko/3.8/glossary.html#term-hashable) : 객체가 일생 그 값이 변하지 않는 해시 값을 갖고(`__hash__()` 메서드 필요), 다른 객체와 비교될 수 있으면(`__eq__()`메서드 필요) 해시 가능하다고 한다. 같다고 비교되는 해시 가능 객체들의 해시 값은 같다. 해시 가능성은 딕셔너리 키나 집합 멤버로 사용할 수 있게 한다. 이 자료구조들이 내부적으로 해시값을 사용하기 때문이다. 대부분 파이썬 불변 내장 객체들은 해시 가능하다. 사용자 정의 클래스의 인스턴스 객체들은 기본적으로 해시 가능하다. 
- 사용자 정의 클래스의 모든 객체가 해시가능하다고 하면서 p.136에 클래스 예제가 등장했는데 왜 해시가능하다고 하고 eq메서드를 재정의하고 나니까 set객체에 add할 때 unhashable해서 안된다고 하는지 이해가 안갔다. 공식문서를 보니 eq와 hash를 둘 다 가져야 한다고 나와있는 걸 보고 이해가 갔다.
- [파이썬 공식문서 - `object.__hash__(self)`](https://docs.python.org/ko/3.8/reference/datamodel.html#object.__hash__) : 내장 함수 hash()와 셋, 딕셔너리 같은 해시형 컬렉셔의 멤버 연산에서 호출된다. 이 메서드는 정수를 돌려줘야 한다. 
  - 사용자 정의 클래스는 기본적으로 `__eq__()`와 `__hash()__` 메서드를 갖는다. 모든 객체는 자기 자신을 제외하고 같지 않다고 비교된다. `__hash__()`는 적절한 값을 돌려줘 x==y일 때 x is y와 hash(x) == hash(y)가 동시에 성립할 수 있게 한다.
  - `__eq__()`를 재정의하고 `__hash__()`를 정의하지 않는 클래스는 `__hash__()`가 None으로 설정된다.(p.137의 첫 번째 클래스 같은 경우) 만약 `__eq__()`를 재정의하는 클래스가 부모 클래스로부터 `__hash__()`의 구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: `__hash__ = <ParentClass>.__hash__`.
  - 사용자 정의 클래스에 기본 값으로 eq와 hash가 들어가있다고 해놓고 eq만 재정의했을 때 오류가 나는 게 이해가 안갔는데 hash역시 명시적으로 재정의 해줘야 한다는 걸 알았다.

---

#### 5-2-3. 합성과 집합화

- 합성composition(그리고 집합화aggregation)은 한 클래스에서 다른 클래스의 인스턴스 변수를 포함하는 것을 말하며, 클래스 간의 관계를 나타낸다. 파이썬 모든 클래스는 상속을 사용한다.(object 베이스 클래스로부터 상속받는다.)
- 합성은 A와 B클래스가 강한 연관 관계를 맺으며 의존성이 강하다. 집은 방을 갖고 집이 있으면 방이 있다.
- 집합화는 A와 B가 연관 관계가 있지만 생명주기가 약하고 독립적이다. 